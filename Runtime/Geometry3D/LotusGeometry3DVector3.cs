//=====================================================================================================================
// Проект: LotusPlatform
// Раздел: Модуль математической системы
// Подраздел: Подсистема 3D геометрии
// Автор: MagistrBYTE aka DanielDem <dementevds@gmail.com>
//---------------------------------------------------------------------------------------------------------------------
/** \file LotusGeometry3DVector3.cs
*		Трехмерный вектор.
*		Реализация трехмерного вектора для реализации базовой информации и представления математических структур данных
*	о трехмерном пространстве.
*/
//---------------------------------------------------------------------------------------------------------------------
// Версия: 1.0.0.0
// Последнее изменение от 30.01.2022
//=====================================================================================================================
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Runtime.InteropServices;
//=====================================================================================================================
namespace Lotus
{
	namespace Maths
	{
		//-------------------------------------------------------------------------------------------------------------
		//! \addtogroup MathGeometry3D
		/*@{*/
		//-------------------------------------------------------------------------------------------------------------
		/// <summary>
		/// Трехмерный вектор
		/// </summary>
		/// <remarks>
		/// Реализация трехмерного вектора, представляющего собой базовую математическую сущность в трехмерном пространстве
		/// </remarks>
		//-------------------------------------------------------------------------------------------------------------
		[Serializable]
		[StructLayout(LayoutKind.Sequential)]
		public struct Vector3D : IEquatable<Vector3D>, IComparable<Vector3D>, ICloneable
		{
			#region ======================================= КОНСТАНТНЫЕ ДАННЫЕ ========================================
			/// <summary>
			/// Единичный вектор
			/// </summary>
			public static readonly Vector3D One = new Vector3D(1, 1, 1);

			/// <summary>
			/// Вектор - право
			/// </summary>
			public static readonly Vector3D Right = new Vector3D(1, 0, 0);

			/// <summary>
			/// Вектор - влево
			/// </summary>
			public static readonly Vector3D Left = new Vector3D(-1, 0, 0);

			/// <summary>
			/// Вектор - вверх
			/// </summary>
			public static readonly Vector3D Up = new Vector3D(0, 1, 0);

			/// <summary>
			/// Вектор - вниз
			/// </summary>
			public static readonly Vector3D Down = new Vector3D(0, -1, 0);

			/// <summary>
			/// Вектор - вперед
			/// </summary>
			public static readonly Vector3D Forward = new Vector3D(0, 0, 1);

			/// <summary>
			/// Вектор - назад
			/// </summary>
			public static readonly Vector3D Back = new Vector3D(0, 0, -1);

			/// <summary>
			/// Нулевой вектор
			/// </summary>
			public static readonly Vector3D Zero = new Vector3D(0, 0, 0);
			#endregion

			#region ======================================= СТАТИЧЕСКИЕ ДАННЫЕ ========================================
			/// <summary>
			/// Текстовый формат отображения параметров вектора
			/// </summary>
			public static String ToStringFormat = "X = {0:0.00}; Y = {1:0.00}; Z = {2:0.00}";

			/// <summary>
			/// Текстовый формат отображения только значений параметров вектора
			/// </summary>
			public static String ToStringFormatValue = "{0:0.00}; {1:0.00}; {2:0.00}";
			#endregion

			#region ======================================= СТАТИЧЕСКИЕ МЕТОДЫ ========================================
			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Сложение векторов
			/// </summary>
			/// <param name="a">Первый вектор</param>
			/// <param name="b">Второй вектор</param>
			/// <param name="result">Результирующий вектор</param>
			//---------------------------------------------------------------------------------------------------------
			public static void Add(ref Vector3D a, ref Vector3D b, out Vector3D result)
			{
				result.X = a.X + b.X;
				result.Y = a.Y + b.Y;
				result.Z = a.Z + b.Z;
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Разность векторов
			/// </summary>
			/// <param name="a">Первый вектор</param>
			/// <param name="b">Второй вектор</param>
			/// <param name="result">Результирующий вектор</param>
			//---------------------------------------------------------------------------------------------------------
			public static void Subtract(ref Vector3D a, ref Vector3D b, out Vector3D result)
			{
				result.X = a.X - b.X;
				result.Y = a.Y - b.Y;
				result.Z = a.Z - b.Z;
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Косинус угла между векторами
			/// </summary>
			/// <param name="from">Начальный вектор</param>
			/// <param name="to">Конечный вектор</param>
			/// <returns>Косинус угла</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Double Cos(ref Vector3D from, ref Vector3D to)
			{
				Double dot = from.X * to.X + from.Y * to.Y + from.Z * to.Z;
				Double ll = from.Length * to.Length;
				return dot / ll;
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Угол между двумя векторами (в градусах)
			/// </summary>
			/// <param name="from">Начальный вектор</param>
			/// <param name="to">Конечные вектор</param>
			/// <returns>Угол в градусах</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Double Angle(ref Vector3D from, ref Vector3D to)
			{
				Double dot = from.X * to.X + from.Y * to.Y + from.Z * to.Z;
				Double ll = from.Length * to.Length;
				Double csv = dot / ll;
				return XMathAngle.NormalizationFull(Math.Acos(csv) * XMath.RadianToDegree_d);
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Расстояние между двумя векторами
			/// </summary>
			/// <param name="a">Первый вектор</param>
			/// <param name="b">Второй вектор</param>
			/// <returns>Расстояние между двумя векторами</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Double Distance(ref Vector3D a, ref Vector3D b)
			{
				Double x = b.X - a.X;
				Double y = b.Y - a.Y;
				Double z = b.Z - a.Z;

				return Math.Sqrt(x * x + y * y + z * z);
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Скалярное произведение векторов
			/// </summary>
			/// <param name="a">Первый вектор</param>
			/// <param name="b">Второй вектор</param>
			/// <returns>Скаляр</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Double Dot(ref Vector3D a, ref Vector3D b)
			{
				return a.X * b.X + a.Y * b.Y + a.Z * b.Z;
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Векторное произведение векторов
			/// </summary>
			/// <param name="left">Левый вектор</param>
			/// <param name="right">Правый вектор</param>
			/// <returns>Вектор, перпендикулярный обоим векторам</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Vector3D Cross(ref Vector3D left, ref Vector3D right)
			{
				return new Vector3D(left.Y * right.Z - left.Z * right.Y,
					left.Z * right.X - left.X * right.Z,
					left.X * right.Y - left.Y * right.X);
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Линейная интерполяция векторов
			/// </summary>
			/// <param name="from">Начальный вектор</param>
			/// <param name="to">Конечный вектор</param>
			/// <param name="time">Время от 0 до 1</param>
			/// <returns>Интерполированный вектор</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Vector3D Lerp(ref Vector3D from, ref Vector3D to, Double time)
			{
				Vector3D vector;
				vector.X = from.X + (to.X - from.X) * time;
				vector.Y = from.Y + (to.Y - from.Y) * time;
				vector.Z = from.Z + (to.Z - from.Z) * time;
				return vector;
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Десереализация трехмерного вектора из строки
			/// </summary>
			/// <param name="data">Строка данных</param>
			/// <returns>Трехмерный вектор</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Vector3D DeserializeFromString(String data)
			{
				Vector3D vector = new Vector3D();
				String[] vector_data = data.Split(';');
				vector.X = XMath.ParseDouble(vector_data[0]);
				vector.Y = XMath.ParseDouble(vector_data[1]);
				vector.Z = XMath.ParseDouble(vector_data[2]);
				return vector;
			}
			#endregion

			#region ======================================= ДАННЫЕ ====================================================
			/// <summary>
			/// Координата X
			/// </summary>
			public Double X;

			/// <summary>
			/// Координата Y
			/// </summary>
			public Double Y;

			/// <summary>
			/// Координата Z
			/// </summary>
			public Double Z;
			#endregion

			#region ======================================= СВОЙСТВА ==================================================
			/// <summary>
			/// Квадрат длины вектора
			/// </summary>
			public Double SqrLength
			{
				get { return X * X + Y * Y + Z * Z; }
			}

			/// <summary>
			/// Длина вектора
			/// </summary>
			public Double Length
			{
				get { return Math.Sqrt(X * X + Y * Y + Z * Z); }
			}

			/// <summary>
			/// Нормализованный вектор
			/// </summary>
			public Vector3D Normalized
			{
				get
				{
					Double inv_lentgh = XMath.InvSqrt(X * X + Y * Y + Z * Z);
					return new Vector3D(X * inv_lentgh, Y * inv_lentgh, Z * inv_lentgh);
				}
			}
			#endregion

			#region ======================================= КОНСТРУКТОРЫ ==============================================
			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Конструктор инициализирует вектор указанными параметрами
			/// </summary>
			/// <param name="x">X - координата</param>
			/// <param name="y">Y - координата</param>
			/// <param name="z">Z - координата</param>
			//---------------------------------------------------------------------------------------------------------
			public Vector3D(Double x, Double y, Double z)
			{
				X = x;
				Y = y;
				Z = z;
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Конструктор инициализирует вектор указанным вектором
			/// </summary>
			/// <param name="source">Вектор</param>
			//---------------------------------------------------------------------------------------------------------
			public Vector3D(Vector3D source)
			{
				X = source.X;
				Y = source.Y;
				Z = source.Z;
			}

#if USE_WINDOWS
			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Конструктор инициализирует вектор указанным вектором WPF
			/// </summary>
			/// <param name="source">Вектор WPF</param>
			//---------------------------------------------------------------------------------------------------------
			public Vector3D(System.Windows.Media.Media3D.Vector3D source)
			{
				X = source.X;
				Y = source.Y;
				Z = source.Z;
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Конструктор инициализирует вектор указанной точкой WPF
			/// </summary>
			/// <param name="source">Точка WPF</param>
			//---------------------------------------------------------------------------------------------------------
			public Vector3D(System.Windows.Media.Media3D.Point3D source)
			{
				X = source.X;
				Y = source.Y;
				Z = source.Z;
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Конструктор инициализирует вектор указанным размером WPF
			/// </summary>
			/// <param name="source">Размер WPF</param>
			//---------------------------------------------------------------------------------------------------------
			public Vector3D(System.Windows.Media.Media3D.Size3D source)
			{
				X = source.X;
				Y = source.Y;
				Z = source.Z;
			}
#endif
			#endregion

			#region ======================================= СИСТЕМНЫЕ МЕТОДЫ ==========================================
			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Проверяет равен ли текущий объект другому объекту того же типа
			/// </summary>
			/// <param name="obj">Сравниваемый объект</param>
			/// <returns>Статус равенства объектов</returns>
			//---------------------------------------------------------------------------------------------------------
			public override Boolean Equals(Object obj)
			{
				if (obj != null)
				{
					if (typeof(Vector3D) == obj.GetType())
					{
						Vector3D vector = (Vector3D)obj;
						return Equals(vector);
					}
				}
				return base.Equals(obj);
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Проверка равенства векторов по значению
			/// </summary>
			/// <param name="other">Сравниваемый вектор</param>
			/// <returns>Статус равенства векторов</returns>
			//---------------------------------------------------------------------------------------------------------
			public Boolean Equals(Vector3D other)
			{
				return this == other;
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Сравнение векторов для упорядочивания
			/// </summary>
			/// <param name="other">Вектор</param>
			/// <returns>Статус сравнения векторов</returns>
			//---------------------------------------------------------------------------------------------------------
			public Int32 CompareTo(Vector3D other)
			{
				if (X > other.X)
				{
					return 1;
				}
				else
				{
					if (X == other.X && Y > other.Y)
					{
						return 1;
					}
					else
					{
						if (X == other.X && Y == other.Y && Z > other.Z)
						{
							return -1;
						}
						else
						{
							return 0;
						}
					}
				}
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Получение хеш-кода вектора
			/// </summary>
			/// <returns>Хеш-код вектора</returns>
			//---------------------------------------------------------------------------------------------------------
			public override Int32 GetHashCode()
			{
				return X.GetHashCode() ^ Y.GetHashCode() ^ Z.GetHashCode();
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Полное копирование вектора
			/// </summary>
			/// <returns>Копия вектора</returns>
			//---------------------------------------------------------------------------------------------------------
			public Object Clone()
			{
				return MemberwiseClone();
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Преобразование к текстовому представлению
			/// </summary>
			/// <returns>Текстовое представление вектора с указанием значений координат</returns>
			//---------------------------------------------------------------------------------------------------------
			public override String ToString()
			{
				return String.Format(ToStringFormat, X, Y, Z);
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Преобразование к текстовому представлению
			/// </summary>
			/// <param name="format">Формат отображения компонентов вектора</param>
			/// <returns>Текстовое представление вектора с указанием значений координат</returns>
			//---------------------------------------------------------------------------------------------------------
			public String ToString(String format)
			{
				return String.Format(ToStringFormat.Replace("0.00", format), X, Y, Z);
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Преобразование к текстовому представлению
			/// </summary>
			/// <returns>Текстовое представление вектора с указанием значений координат</returns>
			//---------------------------------------------------------------------------------------------------------
			public String ToStringValue()
			{
				return String.Format(ToStringFormatValue, X, Y, Z);
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Преобразование к текстовому представлению
			/// </summary>
			/// <param name="format">Формат отображения компонентов вектора</param>
			/// <returns>Текстовое представление вектора с указанием значений координат</returns>
			//---------------------------------------------------------------------------------------------------------
			public String ToStringValue(String format)
			{
				return String.Format(ToStringFormatValue.Replace("0.00", format), X, Y, Z);
			}
			#endregion

			#region ======================================= ОПЕРАТОРЫ =================================================
			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Сложение векторов
			/// </summary>
			/// <param name="left">Первый вектор</param>
			/// <param name="right">Второй вектор</param>
			/// <returns>Сумма векторов</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Vector3D operator +(Vector3D left, Vector3D right)
			{
				return new Vector3D(left.X + right.X, left.Y + right.Y, left.Z + right.Z);
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Вычитание векторов
			/// </summary>
			/// <param name="left">Первый вектор</param>
			/// <param name="right">Второй вектор</param>
			/// <returns>Разность векторов</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Vector3D operator -(Vector3D left, Vector3D right)
			{
				return new Vector3D(left.X - right.X, left.Y - right.Y, left.Z - right.Z);
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Умножение вектора на скаляр
			/// </summary>
			/// <param name="vector">Вектор</param>
			/// <param name="scalar">Скаляр</param>
			/// <returns>Масштабированный вектор</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Vector3D operator *(Vector3D vector, Double scalar)
			{
				return new Vector3D(vector.X * scalar, vector.Y * scalar, vector.Z * scalar);
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Деление вектора на скаляр
			/// </summary>
			/// <param name="vector">Вектор</param>
			/// <param name="scalar">Скаляр</param>
			/// <returns>Масштабированный вектор</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Vector3D operator /(Vector3D vector, Double scalar)
			{
				scalar = 1 / scalar;
				return new Vector3D(vector.X * scalar, vector.Y * scalar, vector.Z * scalar);
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Умножение вектора на вектор. Скалярное произведение векторов
			/// </summary>
			/// <param name="left">Первый вектор</param>
			/// <param name="right">Второй вектор</param>
			/// <returns>Скаляр</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Double operator *(Vector3D left, Vector3D right)
			{
				return left.X * right.X + left.Y * right.Y + left.Z * right.Z;
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Умножение вектора на вектор. Векторное произведение векторов
			/// </summary>
			/// <param name="left">Левый вектор</param>
			/// <param name="right">Правый вектор</param>
			/// <returns>Вектор</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Vector3D operator ^(Vector3D left, Vector3D right)
			{
				return new Vector3D(left.Y * right.Z - left.Z * right.Y,
					left.Z * right.X - left.X * right.Z,
					left.X * right.Y - left.Y * right.X);
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Умножение вектора на матрицу трансформации
			/// </summary>
			/// <param name="vector">Вектор</param>
			/// <param name="matrix">Матрица трансформации</param>
			/// <returns>Трансформированный вектор</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Vector3D operator *(Vector3D vector, Matrix3Dx3 matrix)
			{
				return new Vector3D(vector.X * matrix.M11 + vector.Y * matrix.M21 + vector.Z * matrix.M31,
					vector.X * matrix.M12 + vector.Y * matrix.M22 + vector.Z * matrix.M32,
					vector.X * matrix.M13 + vector.Y * matrix.M23 + vector.Z * matrix.M33);
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Умножение вектора на матрицу трансформации
			/// </summary>
			/// <param name="vector">Вектор</param>
			/// <param name="matrix">Матрица трансформации</param>
			/// <returns>Трансформированный вектор</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Vector3D operator *(Vector3D vector, Matrix4Dx4 matrix)
			{
				return new Vector3D(vector.X * matrix.M11 + vector.Y * matrix.M21 + vector.Z * matrix.M31 + matrix.M41,
					vector.X * matrix.M12 + vector.Y * matrix.M22 + vector.Z * matrix.M32 + matrix.M42,
					vector.X * matrix.M13 + vector.Y * matrix.M23 + vector.Z * matrix.M33 + matrix.M43);
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Сравнение векторов на равенство
			/// </summary>
			/// <param name="left">Первый вектор</param>
			/// <param name="right">Второй вектор</param>
			/// <returns>Статус равенства векторов</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Boolean operator ==(Vector3D left, Vector3D right)
			{
				return left.X == right.X && left.Y == right.Y && left.Z == right.Z;
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Сравнение векторов на неравенство
			/// </summary>
			/// <param name="left">Первый вектор</param>
			/// <param name="right">Второй вектор</param>
			/// <returns>Статус неравенства векторов</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Boolean operator !=(Vector3D left, Vector3D right)
			{
				return left.X != right.X || left.Y != right.Y || left.Z != right.Z;
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Реализация лексикографического порядка отношений векторов
			/// </summary>
			/// <param name="left">Левый вектор</param>
			/// <param name="right">Правый вектор</param>
			/// <returns>Статус меньше</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Boolean operator <(Vector3D left, Vector3D right)
			{
				return left.X < right.X || left.X == right.X && left.Y < right.Y
				                          || left.X == right.X && left.Y == right.Y && left.Z < right.Z;
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Реализация лексикографического порядка отношений векторов
			/// </summary>
			/// <param name="left">Левый вектор</param>
			/// <param name="right">Правый вектор</param>
			/// <returns>Статус больше</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Boolean operator >(Vector3D left, Vector3D right)
			{
				return left.X > right.X || left.X == right.X && left.Y > right.Y
				                          || left.X == right.X && left.Y == right.Y && left.Z > right.Z;
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Обратный вектор
			/// </summary>
			/// <param name="vector">Исходный вектор</param>
			/// <returns>Обратный вектор</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Vector3D operator -(Vector3D vector)
			{
				return new Vector3D(-vector.X, -vector.Y, -vector.Z);
			}
			#endregion

			#region ======================================= ОПЕРАТОРЫ ПРЕОБРАЗОВАНИЯ ==================================
			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Неявное преобразование в объект типа <see cref="Vector3Df"/> 
			/// </summary>
			/// <param name="vector">Вектор</param>
			/// <returns>Объект <see cref="Vector3Df"/> </returns>
			//---------------------------------------------------------------------------------------------------------
			public static implicit operator Vector3Df(Vector3D vector)
			{
				return new Vector3Df((Single)vector.X, (Single)vector.Y, (Single)vector.Z);
			}

#if (UNITY_2017_1_OR_NEWER)
			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Неявное преобразование в объект типа <see cref="UnityEngine.Vector3"/> 
			/// </summary>
			/// <param name="vector">Вектор</param>
			/// <returns>Объект <see cref="UnityEngine.Vector3"/></returns>
			//---------------------------------------------------------------------------------------------------------
			public static implicit operator UnityEngine.Vector3(Vector3D vector)
			{
				return new UnityEngine.Vector3((Single)vector.X, (Single)vector.Y, (Single)vector.Z);
			}
#endif
			#endregion

			#region ======================================= ИНДЕКСАТОР ================================================
			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Индексация компонентов вектора на основе индекса
			/// </summary>
			/// <param name="index">Индекс компонента</param>
			/// <returns>Компонента вектора</returns>
			//---------------------------------------------------------------------------------------------------------
			public Double this[Int32 index]
			{
				get
				{
					switch (index)
					{
						case 0:
							return X;
						case 1:
							return Y;
						default:
							return Z;
					}
				}
				set
				{
					switch (index)
					{
						case 0:
							X = value;
							break;
						case 1:
							Y = value;
							break;
						default:
							Z = value;
							break;
					}
				}
			}
			#endregion

			#region ======================================= ОБЩИЕ МЕТОДЫ ==============================================
			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Нормализация вектора
			/// </summary>
			//---------------------------------------------------------------------------------------------------------
			public void Normalize()
			{
				Double inv_lentgh = XMath.InvSqrt(X * X + Y * Y + Z * Z);
				X *= inv_lentgh;
				Y *= inv_lentgh;
				Z *= inv_lentgh;
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Вычисление расстояние до вектора
			/// </summary>
			/// <param name="vector">Вектор</param>
			/// <returns>Расстояние до вектора</returns>
			//---------------------------------------------------------------------------------------------------------
			public Double Distance(ref Vector3D vector)
			{
				Double x = vector.X - X;
				Double y = vector.Y - Y;
				Double z = vector.Z - Z;

				return Math.Sqrt(x * x + y * y + z * z);
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Вычисление скалярного произведения векторов
			/// </summary>
			/// <param name="vector">Вектор</param>
			/// <returns>Скалярное произведение векторов</returns>
			//---------------------------------------------------------------------------------------------------------
			public Double Dot(ref Vector3D vector)
			{
				return X * vector.X + Y * vector.Y + Z * vector.Z;
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Установка компонентов вектора из наибольших компонентов двух векторов
			/// </summary>
			/// <param name="a">Первый вектор</param>
			/// <param name="b">Второй вектор</param>
			//---------------------------------------------------------------------------------------------------------
			public void SetMaximize(ref Vector3D a, ref Vector3D b)
			{
				X = a.X > b.X ? a.X : b.X;
				Y = a.Y > b.Y ? a.Y : b.Y;
				Z = a.Z > b.Z ? a.Z : b.Z;
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Установка компонентов вектора из наименьших компонентов двух векторов
			/// </summary>
			/// <param name="a">Первый вектор</param>
			/// <param name="b">Второй вектор</param>
			//---------------------------------------------------------------------------------------------------------
			public void SetMinimize(ref Vector3D a, ref Vector3D b)
			{
				X = a.X < b.X ? a.X : b.X;
				Y = a.Y < b.Y ? a.Y : b.Y;
				Z = a.Z < b.Z ? a.Z : b.Z;
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Векторное произведение c нормализацией результата
			/// </summary>
			/// <param name="left">Левый вектор</param>
			/// <param name="right">Правый вектор</param>
			//---------------------------------------------------------------------------------------------------------
			public void CrossNormalize(ref Vector3D left, ref Vector3D right)
			{
				X = left.Y * right.Z - left.Z * right.Y;
				Y = left.Z * right.X - left.X * right.Z;
				Z = left.X * right.Y - left.Y * right.X;
				Double inv_length = XMath.InvSqrt(X * X + Y * Y + Z * Z);
				X *= inv_length;
				Y *= inv_length;
				Z *= inv_length;
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Трансформация вектора как точки
			/// </summary>
			/// <param name="matrix">Матрица трансформации</param>
			//---------------------------------------------------------------------------------------------------------
			public void TransformAsPoint(ref Matrix4Dx4 matrix)
			{
				this = new Vector3D(X * matrix.M11 + Y * matrix.M21 + Z * matrix.M31 + matrix.M41,
									X * matrix.M12 + Y * matrix.M22 + Z * matrix.M32 + matrix.M42,
									X * matrix.M13 + Y * matrix.M23 + Z * matrix.M33 + matrix.M43);
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Трансформация вектора как вектора
			/// </summary>
			/// <param name="matrix">Матрица трансформации</param>
			//---------------------------------------------------------------------------------------------------------
			public void TransformAsVector(ref Matrix4Dx4 matrix)
			{
				this = new Vector3D(X * matrix.M11 + Y * matrix.M21 + Z * matrix.M31,
									X * matrix.M12 + Y * matrix.M22 + Z * matrix.M32,
									X * matrix.M13 + Y * matrix.M23 + Z * matrix.M33);
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Сериализация вектора в строку
			/// </summary>
			/// <returns>Строка данных</returns>
			//---------------------------------------------------------------------------------------------------------
			public String SerializeToString()
			{
				return String.Format("{0};{1};{2}", X, Y, Z);
			}
			#endregion

			#region ======================================= МЕТОДЫ ПРЕОБРАЗОВАНИЙ =====================================
			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Преобразование в вектор нулевой X компонентой
			/// </summary>
			/// <returns>Вектор</returns>
			//---------------------------------------------------------------------------------------------------------
			public Vector2D ToVector2X()
			{
				return new Vector2D(X, 0);
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Преобразование в вектор нулевой Y компонентой
			/// </summary>
			/// <returns>Вектор</returns>
			//---------------------------------------------------------------------------------------------------------
			public Vector2D ToVector2Y()
			{
				return new Vector2D(0, Y);
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Преобразование в двухмерных вектор плоскости XY
			/// </summary>
			/// <returns>Вектор</returns>
			//---------------------------------------------------------------------------------------------------------
			public Vector2D ToVector2XY()
			{
				return new Vector2D(X, Y);
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Преобразование в двухмерных вектор плоскости YZ
			/// </summary>
			/// <returns>Вектор</returns>
			//---------------------------------------------------------------------------------------------------------
			public Vector2D ToVector2XZ()
			{
				return new Vector2D(X, Z);
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Преобразование в двухмерных вектор плоскости YZ
			/// </summary>
			/// <returns>Вектор</returns>
			//---------------------------------------------------------------------------------------------------------
			public Vector2D ToVector2YZ()
			{
				return new Vector2D(Y, Z);
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Преобразование в трехмерный вектор только с компонентой X
			/// </summary>
			/// <returns>Вектор</returns>
			//---------------------------------------------------------------------------------------------------------
			public Vector3D ToVector3X()
			{
				return new Vector3D(X, 0, 0);
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Преобразование в трехмерный вектор только с компонентой Y
			/// </summary>
			/// <returns>Вектор</returns>
			//---------------------------------------------------------------------------------------------------------
			public Vector3D ToVector3Y()
			{
				return new Vector3D(0, Y, 0);
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Преобразование в трехмерный вектор только с компонентой Z
			/// </summary>
			/// <returns>Вектор</returns>
			//---------------------------------------------------------------------------------------------------------
			public Vector3D ToVector3Z()
			{
				return new Vector3D(0, 0, Z);
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Преобразование в трехмерный вектор плоскости XY
			/// </summary>
			/// <returns>Вектор</returns>
			//---------------------------------------------------------------------------------------------------------
			public Vector3D ToVector3XY()
			{
				return new Vector3D(X, Y, 0);
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Преобразование в трехмерный вектор плоскости YZ
			/// </summary>
			/// <returns>Вектор</returns>
			//---------------------------------------------------------------------------------------------------------
			public Vector3D ToVector3XZ()
			{
				return new Vector3D(X, 0, Z);
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Преобразование в трехмерный вектор плоскости YZ
			/// </summary>
			/// <returns>Вектор</returns>
			//---------------------------------------------------------------------------------------------------------
			public Vector3D ToVector3YZ()
			{
				return new Vector3D(0, Y, Z);
			}
			#endregion
		}

		//-------------------------------------------------------------------------------------------------------------
		/// <summary>
		/// Трехмерный вектор
		/// </summary>
		/// <remarks>
		/// Реализация трехмерного вектора, представляющего собой базовую математическую сущность в трехмерном пространстве
		/// </remarks>
		//-------------------------------------------------------------------------------------------------------------
		[Serializable]
		[StructLayout(LayoutKind.Sequential, Pack =4)]
		public struct Vector3Df : IEquatable<Vector3Df>, IComparable<Vector3Df>, ICloneable
		{
			#region ======================================= КОНСТАНТНЫЕ ДАННЫЕ ========================================
			/// <summary>
			/// Единичный вектор
			/// </summary>
			public static readonly Vector3Df One = new Vector3Df(1, 1, 1);

			/// <summary>
			/// Вектор - право
			/// </summary>
			public static readonly Vector3Df Right = new Vector3Df(1, 0, 0);

			/// <summary>
			/// Вектор - влево
			/// </summary>
			public static readonly Vector3Df Left = new Vector3Df(-1, 0, 0);

			/// <summary>
			/// Вектор - вверх
			/// </summary>
			public static readonly Vector3Df Up = new Vector3Df(0, 1, 0);

			/// <summary>
			/// Вектор - вниз
			/// </summary>
			public static readonly Vector3Df Down = new Vector3Df(0, -1, 0);

			/// <summary>
			/// Вектор - вперед
			/// </summary>
			public static readonly Vector3Df Forward = new Vector3Df(0, 0, 1);

			/// <summary>
			/// Вектор - назад
			/// </summary>
			public static readonly Vector3Df Back = new Vector3Df(0, 0, -1);

			/// <summary>
			/// Нулевой вектор
			/// </summary>
			public static readonly Vector3Df Zero = new Vector3Df(0, 0, 0);
			#endregion

			#region ======================================= СТАТИЧЕСКИЕ ДАННЫЕ ========================================
			/// <summary>
			/// Текстовый формат отображения параметров вектора
			/// </summary>
			public static String ToStringFormat = "X = {0:0.000}; Y = {1:0.000}; Z = {2:0.000}";
			#endregion

			#region ======================================= СТАТИЧЕСКИЕ МЕТОДЫ  =======================================
			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Сложение векторов
			/// </summary>
			/// <param name="a">Первый вектор</param>
			/// <param name="b">Второй вектор</param>
			/// <param name="result">Результирующий вектор</param>
			//---------------------------------------------------------------------------------------------------------
			public static void Add(ref Vector3Df a, ref Vector3Df b, out Vector3Df result)
			{
				result.X = a.X + b.X;
				result.Y = a.Y + b.Y;
				result.Z = a.Z + b.Z;
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Разность векторов
			/// </summary>
			/// <param name="a">Первый вектор</param>
			/// <param name="b">Второй вектор</param>
			/// <param name="result">Результирующий вектор</param>
			//---------------------------------------------------------------------------------------------------------
			public static void Subtract(ref Vector3Df a, ref Vector3Df b, out Vector3Df result)
			{
				result.X = a.X - b.X;
				result.Y = a.Y - b.Y;
				result.Z = a.Z - b.Z;
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Масштабирование вектора
			/// </summary>
			/// <param name="vector">Исходный вектор</param>
			/// <param name="scale">Масштаб</param>
			/// <returns>Результирующий вектор</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Vector3Df Scale(Vector3Df vector, Vector3Df scale)
			{
				return (new Vector3Df(vector.X * scale.X, vector.Y * scale.Y, vector.Z * scale.Z));
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Косинус угла между векторами
			/// </summary>
			/// <param name="from">Начальный вектор</param>
			/// <param name="to">Конечный вектор</param>
			/// <returns>Косинус угла</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Single Cos(ref Vector3Df from, ref Vector3Df to)
			{
				Single dot = from.X * to.X + from.Y * to.Y + from.Z * to.Z;
				Single ll = from.Length * to.Length;
				return dot / ll;
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Угол между двумя векторами (в градусах)
			/// </summary>
			/// <param name="from">Начальный вектор</param>
			/// <param name="to">Конечные вектор</param>
			/// <returns>Угол в градусах</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Single Angle(ref Vector3Df from, ref Vector3Df to)
			{
				Single dot = from.X * to.X + from.Y * to.Y + from.Z * to.Z;
				Single ll = from.Length * to.Length;
				Single csv = dot / ll;
				return (Single)XMathAngle.NormalizationFull(Math.Acos(csv) * XMath.RadianToDegree_d);
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Расстояние между двумя векторами
			/// </summary>
			/// <param name="a">Первый вектор</param>
			/// <param name="b">Второй вектор</param>
			/// <returns>Расстояние между двумя векторами</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Single Distance(ref Vector3Df a, ref Vector3Df b)
			{
				Single x = b.X - a.X;
				Single y = b.Y - a.Y;
				Single z = b.Z - a.Z;

				return (Single)Math.Sqrt(x * x + y * y + z * z);
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Расстояние между двумя векторами
			/// </summary>
			/// <param name="a">Первый вектор</param>
			/// <param name="b">Второй вектор</param>
			/// <returns>Расстояние между двумя векторами</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Single Distance(Vector3Df a, Vector3Df b)
			{
				Single x = b.X - a.X;
				Single y = b.Y - a.Y;
				Single z = b.Z - a.Z;

				return (Single)Math.Sqrt(x * x + y * y + z * z);
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Нормализация вектора
			/// </summary>
			/// <param name="vector">Вектор</param>
			/// <returns>Нормализованный вектор</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Vector3Df Normalize(Vector3Df vector)
			{
				Single inv_lentgh = XMath.InvSqrt(vector.X * vector.X + vector.Y * vector.Y + vector.Z * vector.Z);
				return new Vector3Df(vector.X * inv_lentgh, vector.Y * inv_lentgh, vector.Z * inv_lentgh);
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Скалярное произведение векторов
			/// </summary>
			/// <param name="a">Первый вектор</param>
			/// <param name="b">Второй вектор</param>
			/// <returns>Скаляр</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Single Dot(Vector3Df a, Vector3Df b)
			{
				return a.X * b.X + a.Y * b.Y + a.Z * b.Z;
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Скалярное произведение векторов
			/// </summary>
			/// <param name="a">Первый вектор</param>
			/// <param name="b">Второй вектор</param>
			/// <returns>Скаляр</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Single Dot(ref Vector3Df a, ref Vector3Df b)
			{
				return a.X * b.X + a.Y * b.Y + a.Z * b.Z;
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Векторное произведение векторов
			/// </summary>
			/// <param name="left">Левый вектор</param>
			/// <param name="right">Правый вектор</param>
			/// <returns>Вектор, перпендикулярный обоим векторам</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Vector3Df Cross(ref Vector3Df left, ref Vector3Df right)
			{
				return new Vector3Df(left.Y * right.Z - left.Z * right.Y,
					left.Z * right.X - left.X * right.Z,
					left.X * right.Y - left.Y * right.X);
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Векторное произведение векторов
			/// </summary>
			/// <param name="left">Левый вектор</param>
			/// <param name="right">Правый вектор</param>
			/// <returns>Вектор, перпендикулярный обоим векторам</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Vector3Df Cross(Vector3Df left, Vector3Df right)
			{
				return new Vector3Df(left.Y * right.Z - left.Z * right.Y,
					left.Z * right.X - left.X * right.Z,
					left.X * right.Y - left.Y * right.X);
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Векторное произведение векторов
			/// </summary>
			/// <param name="left">Левый вектор</param>
			/// <param name="right">Правый вектор</param>
			/// <param name="result">Вектор, перпендикулярный обоим векторам</param>
			//---------------------------------------------------------------------------------------------------------
			public static void Cross(ref Vector3Df left, ref Vector3Df right, out Vector3Df result)
			{
				result.X = left.Y * right.Z - left.Z * right.Y;
				result.Y = left.Z * right.X - left.X * right.Z;
				result.Z = left.X * right.Y - left.Y * right.X;
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Аппроксимация равенства значений векторов
			/// </summary>
			/// <param name="left">Левый вектор</param>
			/// <param name="right">Правый вектор</param>
			/// <param name="epsilon">Погрешность</param>
			/// <returns>Статус равенства значений векторов</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Boolean Approximately(ref Vector3Df left, ref Vector3Df right, Single epsilon = 0.01f)
			{
				if (Math.Abs(left.X - right.X) < epsilon &&
					Math.Abs(left.Y - right.Y) < epsilon &&
					Math.Abs(left.Z - right.Z) < epsilon)
				{
					return true;
				}

				return false;
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Линейная интерполяция векторов
			/// </summary>
			/// <param name="from">Начальный вектор</param>
			/// <param name="to">Конечный вектор</param>
			/// <param name="time">Время от 0 до 1</param>
			/// <returns>Интерполированный вектор</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Vector3Df Lerp(ref Vector3Df from, ref Vector3Df to, Single time)
			{
				Vector3Df vector;
				vector.X = from.X + (to.X - from.X) * time;
				vector.Y = from.Y + (to.Y - from.Y) * time;
				vector.Z = from.Z + (to.Z - from.Z) * time;
				return vector;
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Получение вектора из сферических координат
			/// </summary>
			/// <remarks>
			/// <para>
			/// https://ru.wikipedia.org/wiki/Сферическая_система_координат
			/// </para>
			/// <para>
			/// Экватор расположен в плоскости XZ, высота по координате Y
			/// В плоскости экватора при взгляде сверху
			/// Вертикальная ось - координата Z
			/// Горизонтальна ось - координата X
			/// </para>
			/// </remarks>
			/// <param name="radius">Радиус</param>
			/// <param name="theta">Угол между осью Y и отрезком, соединяющим начало координат и точку в пределах [0, 180]</param>
			/// <param name="phi">Угол между осью Z и проекцией отрезка, соединяющего начало координат с точкой P, на плоскость XZ в пределах [0, 359]</param>
			/// <returns>Вектор</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Vector3Df FromSpherical(Single radius, Single theta, Single phi)
			{
				Single radian_theta = theta * XMath.DegreeToRadian_f;
				Single radian_phi = phi * XMath.DegreeToRadian_f;
				
				Single z = (Single)(Math.Sin(radian_theta) * Math.Cos(radian_phi)) * radius;
				Single x = (Single)(Math.Sin(radian_theta) * Math.Sin(radian_phi)) * radius;
				Single y = (Single)(Math.Cos(radian_theta)) * radius;

				return (new Vector3Df(x, y, z));
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Получение вектора из сферических координат
			/// </summary>
			/// <remarks>
			/// <para>
			/// https://ru.wikipedia.org/wiki/Сферическая_система_координат
			/// </para>
			/// <para>
			/// Долгота(λ) - угол в горизонтальной плоскости между в пределах [0, 359]
			/// Широта(φ) - угол в вертикальной плоскости в пределах [0, 180]
			/// </para>
			/// <para>
			/// Экватор расположен в плоскости XZ, высота по координате Y
			/// В плоскости экватора при взгляде сверху
			/// Вертикальная ось - координата Z
			/// Горизонтальна ось - координата X
			/// </para>
			/// </remarks>
			/// <param name="radius">Радиус</param>
			/// <param name="latitude">Широта в градусах в пределах [0, 180]</param>
			/// <param name="longitude">Долгота в градусах в пределах [0, 359]</param>
			/// <returns>Вектор</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Vector3Df FromGeographicCoordSystem(Single radius, Single latitude, Single longitude)
			{
				Single theta = latitude * XMath.DegreeToRadian_f;
				Single phi = longitude * XMath.DegreeToRadian_f;

				Single z = (Single)(Math.Sin(theta) * Math.Cos(phi)) * radius;
				Single x = (Single)(Math.Sin(theta) * Math.Sin(phi)) * radius;
				Single y = (Single)(Math.Cos(theta)) * radius;

				return (new Vector3Df(x, y, z));
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Получение вектора перпендикулярного указанной плоскости
			/// </summary>
			/// <param name="plane_type">Плоскость</param>
			/// <returns>Вектор</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Vector3Df GetPerpendicularPlane(TDimensionPlane plane_type)
			{
				if(plane_type == TDimensionPlane.XZ)
				{
					return (Vector3Df.Up);
				}
				else
				{
					if (plane_type == TDimensionPlane.ZY)
					{
						return (Vector3Df.Right);
					}
					else
					{
						return (Vector3Df.Forward);
					}
				}
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Десереализация трехмерного вектора из строки
			/// </summary>
			/// <param name="data">Строка данных</param>
			/// <returns>Двухмерный вектор</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Vector3Df DeserializeFromString(String data)
			{
				Vector3Df vector = new Vector3Df();
				String[] vector_data = data.Split(';');
				vector.X = XMath.ParseSingle(vector_data[0]);
				vector.Y = XMath.ParseSingle(vector_data[1]);
				vector.Z = XMath.ParseSingle(vector_data[2]);
				return vector;
			}
			#endregion

			#region ======================================= ДАННЫЕ ====================================================
			/// <summary>
			/// Координата X
			/// </summary>
			public Single X;

			/// <summary>
			/// Координата Y
			/// </summary>
			public Single Y;

			/// <summary>
			/// Координата Z
			/// </summary>
			public Single Z;
			#endregion

			#region ======================================= СВОЙСТВА ==================================================
			/// <summary>
			/// Квадрат длины вектора
			/// </summary>
			public Single SqrLength
			{
				get { return X * X + Y * Y + Z * Z; }
			}

			/// <summary>
			/// Длина вектора
			/// </summary>
			public Single Length
			{
				get { return (Single)Math.Sqrt(X * X + Y * Y + Z * Z); }
			}

			/// <summary>
			/// Нормализованный вектор
			/// </summary>
			public Vector3Df Normalized
			{
				get
				{
					Single inv_lentgh = XMath.InvSqrt(X * X + Y * Y + Z * Z);
					return new Vector3Df(X * inv_lentgh, Y * inv_lentgh, Z * inv_lentgh);
				}
			}
			#endregion

			#region ======================================= КОНСТРУКТОРЫ ==============================================
			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Конструктор инициализирует вектор указанными параметрами
			/// </summary>
			/// <param name="x">X - координата</param>
			/// <param name="y">Y - координата</param>
			/// <param name="z">Z - координата</param>
			//---------------------------------------------------------------------------------------------------------
			public Vector3Df(Single x, Single y, Single z)
			{
				X = x;
				Y = y;
				Z = z;
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Конструктор инициализирует вектор указанным вектором
			/// </summary>
			/// <param name="source">Вектор</param>
			//---------------------------------------------------------------------------------------------------------
			public Vector3Df(Vector3Df source)
			{
				X = source.X;
				Y = source.Y;
				Z = source.Z;
			}
			#endregion

			#region ======================================= СИСТЕМНЫЕ МЕТОДЫ ==========================================
			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Проверяет равен ли текущий объект другому объекту того же типа
			/// </summary>
			/// <param name="obj">Сравниваемый объект</param>
			/// <returns>Статус равенства объектов</returns>
			//---------------------------------------------------------------------------------------------------------
			public override Boolean Equals(Object obj)
			{
				if (obj != null)
				{
					if (typeof(Vector3Df) == obj.GetType())
					{
						Vector3Df vector = (Vector3Df)obj;
						return Equals(vector);
					}
				}
				return base.Equals(obj);
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Проверка равенства векторов по значению
			/// </summary>
			/// <param name="other">Сравниваемый вектор</param>
			/// <returns>Статус равенства векторов</returns>
			//---------------------------------------------------------------------------------------------------------
			public Boolean Equals(Vector3Df other)
			{
				return this == other;
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Сравнение векторов для упорядочивания
			/// </summary>
			/// <param name="other">Вектор</param>
			/// <returns>Статус сравнения векторов</returns>
			//---------------------------------------------------------------------------------------------------------
			public Int32 CompareTo(Vector3Df other)
			{
				if (X > other.X)
				{
					return 1;
				}
				else
				{
					if (X == other.X && Y > other.Y)
					{
						return 1;
					}
					else
					{
						if (X == other.X && Y == other.Y && Z > other.Z)
						{
							return -1;
						}
						else
						{
							return 0;
						}
					}
				}
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Получение хеш-кода вектора
			/// </summary>
			/// <returns>Хеш-код вектора</returns>
			//---------------------------------------------------------------------------------------------------------
			public override Int32 GetHashCode()
			{
				return X.GetHashCode() ^ Y.GetHashCode() ^ Z.GetHashCode();
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Полное копирование вектора
			/// </summary>
			/// <returns>Копия вектора</returns>
			//---------------------------------------------------------------------------------------------------------
			public Object Clone()
			{
				return MemberwiseClone();
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Преобразование к текстовому представлению
			/// </summary>
			/// <returns>Текстовое представление вектора с указанием значений координат</returns>
			//---------------------------------------------------------------------------------------------------------
			public override String ToString()
			{
				return String.Format(ToStringFormat, X, Y, Z);
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Преобразование к текстовому представлению
			/// </summary>
			/// <param name="format">Формат отображения компонентов вектора</param>
			/// <returns>Текстовое представление вектора с указанием значений координат</returns>
			//---------------------------------------------------------------------------------------------------------
			public String ToString(String format)
			{
				return String.Format(format, X, Y, Z);
			}
			#endregion

			#region ======================================= ОПЕРАТОРЫ =================================================
			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Сложение векторов
			/// </summary>
			/// <param name="left">Первый вектор</param>
			/// <param name="right">Второй вектор</param>
			/// <returns>Сумма векторов</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Vector3Df operator +(Vector3Df left, Vector3Df right)
			{
				return new Vector3Df(left.X + right.X, left.Y + right.Y, left.Z + right.Z);
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Вычитание векторов
			/// </summary>
			/// <param name="left">Первый вектор</param>
			/// <param name="right">Второй вектор</param>
			/// <returns>Разность векторов</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Vector3Df operator -(Vector3Df left, Vector3Df right)
			{
				return new Vector3Df(left.X - right.X, left.Y - right.Y, left.Z - right.Z);
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Умножение вектора на скаляр
			/// </summary>
			/// <param name="vector">Вектор</param>
			/// <param name="scalar">Скаляр</param>
			/// <returns>Масштабированный вектор</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Vector3Df operator *(Single scalar, Vector3Df vector)
			{
				return new Vector3Df(vector.X * scalar, vector.Y * scalar, vector.Z * scalar);
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Умножение вектора на скаляр
			/// </summary>
			/// <param name="vector">Вектор</param>
			/// <param name="scalar">Скаляр</param>
			/// <returns>Масштабированный вектор</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Vector3Df operator *(Vector3Df vector, Single scalar)
			{
				return new Vector3Df(vector.X * scalar, vector.Y * scalar, vector.Z * scalar);
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Деление вектора на скаляр
			/// </summary>
			/// <param name="vector">Вектор</param>
			/// <param name="scalar">Скаляр</param>
			/// <returns>Масштабированный вектор</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Vector3Df operator /(Single scalar, Vector3Df vector)
			{
				scalar = 1 / scalar;
				return new Vector3Df(vector.X * scalar, vector.Y * scalar, vector.Z * scalar);
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Деление вектора на скаляр
			/// </summary>
			/// <param name="vector">Вектор</param>
			/// <param name="scalar">Скаляр</param>
			/// <returns>Масштабированный вектор</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Vector3Df operator /(Vector3Df vector, Single scalar)
			{
				scalar = 1 / scalar;
				return new Vector3Df(vector.X * scalar, vector.Y * scalar, vector.Z * scalar);
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Умножение вектора на вектор. Скалярное произведение векторов
			/// </summary>
			/// <param name="left">Первый вектор</param>
			/// <param name="right">Второй вектор</param>
			/// <returns>Скаляр</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Single operator *(Vector3Df left, Vector3Df right)
			{
				return left.X * right.X + left.Y * right.Y + left.Z * right.Z;
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Умножение вектора на вектор. Векторное произведение векторов
			/// </summary>
			/// <param name="left">Левый вектор</param>
			/// <param name="right">Правый вектор</param>
			/// <returns>Вектор</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Vector3Df operator ^(Vector3Df left, Vector3Df right)
			{
				return new Vector3Df(left.Y * right.Z - left.Z * right.Y,
					left.Z * right.X - left.X * right.Z,
					left.X * right.Y - left.Y * right.X);
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Умножение вектора на матрицу трансформации
			/// </summary>
			/// <param name="vector">Вектор</param>
			/// <param name="matrix">Матрица трансформации</param>
			/// <returns>Трансформированный вектор</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Vector3Df operator *(Vector3Df vector, Matrix3Dx3f matrix)
			{
				return new Vector3Df(vector.X * matrix.M11 + vector.Y * matrix.M21 + vector.Z * matrix.M31,
					vector.X * matrix.M12 + vector.Y * matrix.M22 + vector.Z * matrix.M32,
					vector.X * matrix.M13 + vector.Y * matrix.M23 + vector.Z * matrix.M33);
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Умножение вектора на матрицу трансформации
			/// </summary>
			/// <param name="vector">Вектор</param>
			/// <param name="matrix">Матрица трансформации</param>
			/// <returns>Трансформированный вектор</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Vector3Df operator *(Vector3Df vector, Matrix4Dx4 matrix)
			{
				Single x = (Single)(vector.X * matrix.M11 + vector.Y * matrix.M21 + vector.Z * matrix.M31 + matrix.M41);
				Single y = (Single)(vector.X * matrix.M12 + vector.Y * matrix.M22 + vector.Z * matrix.M32 + matrix.M42);
				Single z = (Single)(vector.X * matrix.M13 + vector.Y * matrix.M23 + vector.Z * matrix.M33 + matrix.M43);
				return new Vector3Df(x, y, z);
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Сравнение векторов на равенство
			/// </summary>
			/// <param name="left">Первый вектор</param>
			/// <param name="right">Второй вектор</param>
			/// <returns>Статус равенства векторов</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Boolean operator ==(Vector3Df left, Vector3Df right)
			{
				return left.X == right.X && left.Y == right.Y && left.Z == right.Z;
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Сравнение векторов на неравенство
			/// </summary>
			/// <param name="left">Первый вектор</param>
			/// <param name="right">Второй вектор</param>
			/// <returns>Статус неравенства векторов</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Boolean operator !=(Vector3Df left, Vector3Df right)
			{
				return left.X != right.X || left.Y != right.Y || left.Z != right.Z;
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Реализация лексикографического порядка отношений векторов
			/// </summary>
			/// <param name="left">Левый вектор</param>
			/// <param name="right">Правый вектор</param>
			/// <returns>Статус меньше</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Boolean operator <(Vector3Df left, Vector3Df right)
			{
				return left.X < right.X || left.X == right.X && left.Y < right.Y
					|| left.X == right.X && left.Y == right.Y && left.Z < right.Z;
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Реализация лексикографического порядка отношений векторов
			/// </summary>
			/// <param name="left">Левый вектор</param>
			/// <param name="right">Правый вектор</param>
			/// <returns>Статус больше</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Boolean operator >(Vector3Df left, Vector3Df right)
			{
				return left.X > right.X || left.X == right.X && left.Y > right.Y
					|| left.X == right.X && left.Y == right.Y && left.Z > right.Z;
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Обратный вектор
			/// </summary>
			/// <param name="vector">Исходный вектор</param>
			/// <returns>Обратный вектор</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Vector3Df operator -(Vector3Df vector)
			{
				return new Vector3Df(-vector.X, -vector.Y, -vector.Z);
			}
			#endregion

			#region ======================================= ОПЕРАТОРЫ ПРЕОБРАЗОВАНИЯ ==================================
#if (UNITY_2017_1_OR_NEWER)
			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Неявное преобразование в объект типа <see cref="UnityEngine.Vector3"/> 
			/// </summary>
			/// <param name="vector">Вектор</param>
			/// <returns>Объект <see cref="UnityEngine.Vector3"/></returns>
			//---------------------------------------------------------------------------------------------------------
			public static implicit operator UnityEngine.Vector3(Vector3Df vector)
			{
				return new UnityEngine.Vector3(vector.X, vector.Y, vector.Z);
			}
#endif
			#endregion

			#region ======================================= ИНДЕКСАТОР ================================================
			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Индексация компонентов вектора на основе индекса
			/// </summary>
			/// <param name="index">Индекс компонента</param>
			/// <returns>Компонента вектора</returns>
			//---------------------------------------------------------------------------------------------------------
			public Single this[Int32 index]
			{
				get
				{
					switch (index)
					{
						case 0:
							return X;
						case 1:
							return Y;
						default:
							return Z;
					}
				}
				set
				{
					switch (index)
					{
						case 0:
							X = value;
							break;
						case 1:
							Y = value;
							break;
						default:
							Z = value;
							break;
					}
				}
			}
			#endregion

			#region ======================================= ОБЩИЕ МЕТОДЫ ==============================================
			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Нормализация вектора
			/// </summary>
			//---------------------------------------------------------------------------------------------------------
			public void Normalize()
			{
				Single inv_lentgh = XMath.InvSqrt(X * X + Y * Y + Z * Z);
				X *= inv_lentgh;
				Y *= inv_lentgh;
				Z *= inv_lentgh;
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Вычисление расстояние до вектора
			/// </summary>
			/// <param name="vector">Вектор</param>
			/// <returns>Расстояние до вектора</returns>
			//---------------------------------------------------------------------------------------------------------
			public Single Distance(ref Vector3Df vector)
			{
				Single x = vector.X - X;
				Single y = vector.Y - Y;
				Single z = vector.Z - Z;

				return (Single)Math.Sqrt(x * x + y * y + z * z);
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Вычисление скалярного произведения векторов
			/// </summary>
			/// <param name="vector">Вектор</param>
			/// <returns>Скалярное произведение векторов</returns>
			//---------------------------------------------------------------------------------------------------------
			public Single Dot(ref Vector3Df vector)
			{
				return X * vector.X + Y * vector.Y + Z * vector.Z;
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Установка компонентов вектора из наибольших компонентов двух векторов
			/// </summary>
			/// <param name="a">Первый вектор</param>
			/// <param name="b">Второй вектор</param>
			//---------------------------------------------------------------------------------------------------------
			public void SetMaximize(ref Vector3Df a, ref Vector3Df b)
			{
				X = a.X > b.X ? a.X : b.X;
				Y = a.Y > b.Y ? a.Y : b.Y;
				Z = a.Z > b.Z ? a.Z : b.Z;
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Установка компонентов вектора из наименьших компонентов двух векторов
			/// </summary>
			/// <param name="a">Первый вектор</param>
			/// <param name="b">Второй вектор</param>
			//---------------------------------------------------------------------------------------------------------
			public void SetMinimize(ref Vector3Df a, ref Vector3Df b)
			{
				X = a.X < b.X ? a.X : b.X;
				Y = a.Y < b.Y ? a.Y : b.Y;
				Z = a.Z < b.Z ? a.Z : b.Z;
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Векторное произведение c нормализацией результата
			/// </summary>
			/// <param name="left">Левый вектор</param>
			/// <param name="right">Правый вектор</param>
			//---------------------------------------------------------------------------------------------------------
			public void CrossNormalize(ref Vector3Df left, ref Vector3Df right)
			{
				X = left.Y * right.Z - left.Z * right.Y;
				Y = left.Z * right.X - left.X * right.Z;
				Z = left.X * right.Y - left.Y * right.X;
				Single inv_length = XMath.InvSqrt(X * X + Y * Y + Z * Z);
				X *= inv_length;
				Y *= inv_length;
				Z *= inv_length;
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Трансформация вектора как точки
			/// </summary>
			/// <param name="matrix">Матрица трансформации</param>
			//---------------------------------------------------------------------------------------------------------
			public void TransformAsPoint(ref Matrix4Dx4 matrix)
			{
				Single x = (Single)(X * matrix.M11 + Y * matrix.M21 + Z * matrix.M31 + matrix.M41);
				Single y = (Single)(X * matrix.M12 + Y * matrix.M22 + Z * matrix.M32 + matrix.M42);
				Single z = (Single)(X * matrix.M13 + Y * matrix.M23 + Z * matrix.M33 + matrix.M43);
				X = x;
				Y = y;
				Z = z;
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Трансформация вектора как вектора
			/// </summary>
			/// <param name="matrix">Матрица трансформации</param>
			//---------------------------------------------------------------------------------------------------------
			public void TransformAsVector(ref Matrix4Dx4 matrix)
			{
				Single x = (Single)(X * matrix.M11 + Y * matrix.M21 + Z * matrix.M31);
				Single y = (Single)(X * matrix.M12 + Y * matrix.M22 + Z * matrix.M32);
				Single z = (Single)(X * matrix.M13 + Y * matrix.M23 + Z * matrix.M33);
				X = x;
				Y = y;
				Z = z;
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Сериализация вектора в строку
			/// </summary>
			/// <returns>Строка данных</returns>
			//---------------------------------------------------------------------------------------------------------
			public String SerializeToString()
			{
				return String.Format("{0};{1};{2}", X, Y, Z);
			}
			#endregion

			#region ======================================= МЕТОДЫ ПРЕОБРАЗОВАНИЙ =====================================
			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Преобразование в вектор нулевой X компонентой
			/// </summary>
			/// <returns>Вектор</returns>
			//---------------------------------------------------------------------------------------------------------
			public Vector2Df ToVector2X()
			{
				return new Vector2Df(X, 0);
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Преобразование в вектор нулевой Y компонентой
			/// </summary>
			/// <returns>Вектор</returns>
			//---------------------------------------------------------------------------------------------------------
			public Vector2Df ToVector2Y()
			{
				return new Vector2Df(0, Y);
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Преобразование в двухмерных вектор плоскости XY
			/// </summary>
			/// <returns>Вектор</returns>
			//---------------------------------------------------------------------------------------------------------
			public Vector2Df ToVector2XY()
			{
				return new Vector2Df(X, Y);
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Преобразование в двухмерных вектор плоскости YZ
			/// </summary>
			/// <returns>Вектор</returns>
			//---------------------------------------------------------------------------------------------------------
			public Vector2Df ToVector2XZ()
			{
				return new Vector2Df(X,Z);
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Преобразование в двухмерных вектор плоскости YZ
			/// </summary>
			/// <returns>Вектор</returns>
			//---------------------------------------------------------------------------------------------------------
			public Vector2Df ToVector2YZ()
			{
				return new Vector2Df(Y, Z);
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Преобразование в трехмерный вектор только с компонентой X
			/// </summary>
			/// <returns>Вектор</returns>
			//---------------------------------------------------------------------------------------------------------
			public Vector3Df ToVector3X()
			{
				return new Vector3Df(X, 0, 0);
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Преобразование в трехмерный вектор только с компонентой Y
			/// </summary>
			/// <returns>Вектор</returns>
			//---------------------------------------------------------------------------------------------------------
			public Vector3Df ToVector3Y()
			{
				return new Vector3Df(0, Y, 0);
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Преобразование в трехмерный вектор только с компонентой Z
			/// </summary>
			/// <returns>Вектор</returns>
			//---------------------------------------------------------------------------------------------------------
			public Vector3Df ToVector3Z()
			{
				return new Vector3Df(0, 0, Z);
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Преобразование в трехмерный вектор плоскости XY
			/// </summary>
			/// <returns>Вектор</returns>
			//---------------------------------------------------------------------------------------------------------
			public Vector3Df ToVector3XY()
			{
				return new Vector3Df(X, Y, 0);
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Преобразование в трехмерный вектор плоскости YZ
			/// </summary>
			/// <returns>Вектор</returns>
			//---------------------------------------------------------------------------------------------------------
			public Vector3Df ToVector3XZ()
			{
				return new Vector3Df(X, 0, Z);
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Преобразование в трехмерный вектор плоскости YZ
			/// </summary>
			/// <returns>Вектор</returns>
			//---------------------------------------------------------------------------------------------------------
			public Vector3Df ToVector3YZ()
			{
				return new Vector3Df(0, Y, Z);
			}
			#endregion
		}
		//-------------------------------------------------------------------------------------------------------------
		/*@}*/
		//-------------------------------------------------------------------------------------------------------------
	}
}
//=====================================================================================================================