//=====================================================================================================================
// Проект: LotusPlatform
// Раздел: Модуль математической системы
// Подраздел: Подсистема 2D геометрии
// Автор: MagistrBYTE aka DanielDem <dementevds@gmail.com>
//---------------------------------------------------------------------------------------------------------------------
/** \file LotusGeometry2DVector2.cs
*		Двухмерный вектор.
*		Реализация двухмерного вектора представляющего собой базовую сущность 2 двухмерном пространстве.
*/
//---------------------------------------------------------------------------------------------------------------------
// Версия: 1.0.0.0
// Последнее изменение от 30.01.2022
//=====================================================================================================================
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
//=====================================================================================================================
namespace Lotus
{
	namespace Maths
	{
		//-------------------------------------------------------------------------------------------------------------
		//! \addtogroup MathGeometry2D
		/*@{*/
		//-------------------------------------------------------------------------------------------------------------
		/// <summary>
		/// Двухмерный вектор
		/// </summary>
		/// <remarks>
		/// Реализация двухмерного вектора, представляющего собой базовую математическую сущность в двухмерном пространстве
		/// </remarks>
		//-------------------------------------------------------------------------------------------------------------
		[Serializable]
		[StructLayout(LayoutKind.Sequential, Pack = 4)]
		public struct Vector2D : IEquatable<Vector2D>, IComparable<Vector2D>, ICloneable
		{
			#region ======================================= КОНСТАНТНЫЕ ДАННЫЕ ========================================
			/// <summary>
			/// Единичный вектор
			/// </summary>
			public static readonly Vector2D One = new Vector2D(1, 1);

			/// <summary>
			/// Вектор "право"
			/// </summary>
			public static readonly Vector2D Right = new Vector2D(1, 0);

			/// <summary>
			/// Вектор "влево"
			/// </summary>
			public static readonly Vector2D Left = new Vector2D(-1, 0);

			/// <summary>
			/// Вектор "вверх"
			/// </summary>
			public static readonly Vector2D Up = new Vector2D(0, 1);

			/// <summary>
			/// Вектор "вниз"
			/// </summary>
			public static readonly Vector2D Down = new Vector2D(0, -1);

			/// <summary>
			/// Нулевой вектор
			/// </summary>
			public static readonly Vector2D Zero = new Vector2D(0, 0);
			#endregion

			#region ======================================= СТАТИЧЕСКИЕ ДАННЫЕ ========================================
			/// <summary>
			/// Текстовый формат отображения параметров вектора
			/// </summary>
			public static String ToStringFormat = "X = {0:0.00}; Y = {1:0.00}";

			/// <summary>
			/// Текстовый формат отображения только значений параметров вектора
			/// </summary>
			public static String ToStringFormatValue = "{0:0.00}; {1:0.00}";
			#endregion

			#region ======================================= СТАТИЧЕСКИЕ МЕТОДЫ ========================================
			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Косинус угла между векторами
			/// </summary>
			/// <param name="from">Начальный вектор</param>
			/// <param name="to">Конечный вектор</param>
			/// <returns>Косинус угла</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Double Cos(ref Vector2D from, ref Vector2D to)
			{
				Double dot = from.X * to.X + from.Y * to.Y;
				Double ll = from.Length * to.Length;
				return dot / ll;
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Угол между двумя векторами (в градусах)
			/// </summary>
			/// <param name="from">Начальный вектор</param>
			/// <param name="to">Конечные вектор</param>
			/// <returns>Угол в градусах</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Double Angle(ref Vector2D from, ref Vector2D to)
			{
				Double dot = from.X * to.X + from.Y * to.Y;
				Double ll = from.Length * to.Length;
				Double csv = dot / ll;
				return Math.Acos(csv) * XMath.RadianToDegree_d;
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Расстояние между двумя векторами
			/// </summary>
			/// <param name="a">Первый вектор</param>
			/// <param name="b">Второй вектор</param>
			/// <returns>Расстояние между двумя векторами</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Double Distance(ref Vector2D a, ref Vector2D b)
			{
				Double x = b.X - a.X;
				Double y = b.Y - a.Y;

				return Math.Sqrt(x * x + y * y);
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Скалярное произведение векторов
			/// </summary>
			/// <param name="a">Первый вектор</param>
			/// <param name="b">Второй вектор</param>
			/// <returns>Скаляр</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Double Dot(ref Vector2D a, ref Vector2D b)
			{
				return a.X * b.X + a.Y * b.Y;
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Линейная интерполяция векторов
			/// </summary>
			/// <param name="from">Начальный вектор</param>
			/// <param name="to">Конечный вектор</param>
			/// <param name="time">Время от 0 до 1</param>
			/// <returns>Интерполированный вектор</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Vector2D Lerp(ref Vector2D from, ref Vector2D to, Double time)
			{
				Vector2D vector;
				vector.X = from.X + (to.X - from.X) * time;
				vector.Y = from.Y + (to.Y - from.Y) * time;
				return vector;
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Негативное значение для вектора
			/// </summary>
			/// <param name="value">Исходный вектор</param>
			/// <returns>Негативный вектор</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Vector2D Negate(ref Vector2D value)
			{
				return new Vector2D(-value.X, -value.Y);
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Максимальное значение из компонентов векторов
			/// </summary>
			/// <param name="a">Первый вектор</param>
			/// <param name="b">Второй вектор</param>
			/// <param name="result">Результирующий вектор</param>
			//---------------------------------------------------------------------------------------------------------
			public static void Max(ref Vector2D a, ref Vector2D b, out Vector2D result)
			{
				result.X = a.X > b.X ? a.X : b.X;
				result.Y = a.Y > b.Y ? a.Y : b.Y;
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Максимальное значение из компонентов векторов
			/// </summary>
			/// <param name="a">Первый вектор</param>
			/// <param name="b">Второй вектор</param>
			/// <returns>Результирующий вектор</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Vector2D Max(ref Vector2D a, ref Vector2D b)
			{
				return new Vector2D(a.X > b.X ? a.X : b.X, a.Y > b.Y ? a.Y : b.Y);
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Минимальное значение из компонентов векторов
			/// </summary>
			/// <param name="a">Первый вектор</param>
			/// <param name="b">Второй вектор</param>
			/// <param name="result">Результирующий вектор</param>
			//---------------------------------------------------------------------------------------------------------
			public static void Min(ref Vector2D a, ref Vector2D b, out Vector2D result)
			{
				result.X = a.X < b.X ? a.X : b.X;
				result.Y = a.Y < b.Y ? a.Y : b.Y;
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Минимальное значение из компонентов векторов
			/// </summary>
			/// <param name="a">Первый вектор</param>
			/// <param name="b">Второй вектор</param>
			/// <returns>Результирующий вектор</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Vector2D Min(ref Vector2D a, ref Vector2D b)
			{
				return new Vector2D(a.X < b.X ? a.X : b.X, a.Y < b.Y ? a.Y : b.Y);
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Отражение вектора относительно нормали
			/// </summary>
			/// <param name="vector">Исходный вектор</param>
			/// <param name="normal">Вектор нормали</param>
			/// <param name="result">Результирующий вектор</param>
			//---------------------------------------------------------------------------------------------------------
			public static void Reflect(ref Vector2D vector, ref Vector2D normal, out Vector2D result)
			{
				Double dot = vector.X * normal.X + vector.Y * normal.Y;

				result.X = vector.X - 2.0 * dot * normal.X;
				result.Y = vector.Y - 2.0 * dot * normal.Y;
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Отражение вектора относительно нормали
			/// </summary>
			/// <param name="vector">Исходный вектор</param>
			/// <param name="normal">Вектор нормали</param>
			/// <returns>Результирующий вектор</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Vector2D Reflect(ref Vector2D vector, ref Vector2D normal)
			{
				Vector2D result;
				Reflect(ref vector, ref normal, out result);
				return result;
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Аппроксимация равенства значений векторов
			/// </summary>
			/// <param name="a">Первый вектор</param>
			/// <param name="b">Второй вектор</param>
			/// <param name="epsilon">Погрешность</param>
			/// <returns>Статус равенства значений</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Boolean Approximately(ref Vector2D a, ref Vector2D b, Single epsilon = 0.001f)
			{
				if (Math.Abs(a.X - b.X) < epsilon && Math.Abs(a.Y - b.Y) < epsilon)
				{
					return true;
				}

				return false;
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Десереализация двухмерного вектора из строки
			/// </summary>
			/// <param name="data">Строка данных</param>
			/// <returns>Двухмерный вектор</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Vector2D DeserializeFromString(String data)
			{
				Vector2D vector = new Vector2D();
				String[] vector_data = data.Split(';');
				vector.X = XMath.ParseDouble(vector_data[0]);
				vector.Y = XMath.ParseDouble(vector_data[1]);
				return vector;
			}
			#endregion

			#region ======================================= ДАННЫЕ ====================================================
			/// <summary>
			/// Компонента X
			/// </summary>
			public Double X;

			/// <summary>
			/// Компонента Y
			/// </summary>
			public Double Y;
			#endregion

			#region ======================================= СВОЙСТВА ==================================================
			/// <summary>
			/// Квадрат длины вектора
			/// </summary>
			public Double SqrLength
			{
				get { return X * X + Y * Y; }
			}

			/// <summary>
			/// Длина вектора
			/// </summary>
			public Double Length
			{
				get { return Math.Sqrt(X * X + Y * Y); }
			}

			/// <summary>
			/// Нормализованный вектор
			/// </summary>
			public Vector2D Normalized
			{
				get
				{
					Double inv_lentgh = XMath.InvSqrt(X * X + Y * Y);
					return new Vector2D(X * inv_lentgh, Y * inv_lentgh);
				}
			}
			#endregion

			#region ======================================= КОНСТРУКТОРЫ ==============================================
			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Конструктор инициализирует вектор указанными параметрами
			/// </summary>
			/// <param name="x">X - координата</param>
			/// <param name="y">Y - координата</param>
			//---------------------------------------------------------------------------------------------------------
			public Vector2D(Double x, Double y)
			{
				X = x;
				Y = y;
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Конструктор инициализирует вектор указанным вектором
			/// </summary>
			/// <param name="source">Вектор</param>
			//---------------------------------------------------------------------------------------------------------
			public Vector2D(Vector2D source)
			{
				X = source.X;
				Y = source.Y;
			}
#if USE_WINDOWS
			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Конструктор инициализирует вектор указанной точкой WPF
			/// </summary>
			/// <param name="source">Точка WPF</param>
			//---------------------------------------------------------------------------------------------------------
			public Vector2D(System.Windows.Point source)
			{
				X = source.X;
				Y = source.Y;
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Конструктор инициализирует вектор разностью точек WPF
			/// </summary>
			/// <param name="start">Начальная точка WPF</param>
			/// <param name="end">Конечная точка WPF</param>
			//---------------------------------------------------------------------------------------------------------
			public Vector2D(System.Windows.Point start, System.Windows.Point end)
			{
				X = end.X - start.X;
				Y = end.Y - start.Y;
			}
#endif
#if USE_SHARPDX
			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Конструктор инициализирует вектор указанным вектором SharpDX
			/// </summary>
			/// <param name="source">Вектор SharpDX</param>
			//---------------------------------------------------------------------------------------------------------
			public Vector2D(global::SharpDX.Vector2 source)
			{
				X = source.X;
				Y = source.Y;
			}
#endif
			#endregion

			#region ======================================= СИСТЕМНЫЕ МЕТОДЫ ==========================================
			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Проверяет равен ли текущий объект другому объекту того же типа
			/// </summary>
			/// <param name="obj">Сравниваемый объект</param>
			/// <returns>Статус равенства объектов</returns>
			//---------------------------------------------------------------------------------------------------------
			public override Boolean Equals(Object obj)
			{
				if (obj != null)
				{
					if (typeof(Vector2D) == obj.GetType())
					{
						Vector2D vector = (Vector2D)obj;
						return Equals(vector);
					}
				}
				return base.Equals(obj);
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Проверка равенства векторов по значению
			/// </summary>
			/// <param name="other">Сравниваемый вектор</param>
			/// <returns>Статус равенства векторов</returns>
			//---------------------------------------------------------------------------------------------------------
			public Boolean Equals(Vector2D other)
			{
				return this == other;
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Сравнение векторов для упорядочивания
			/// </summary>
			/// <param name="other">Вектор</param>
			/// <returns>Статус сравнения векторов</returns>
			//---------------------------------------------------------------------------------------------------------
			public Int32 CompareTo(Vector2D other)
			{
				if (X > other.X)
				{
					return 1;
				}
				else
				{
					if (X == other.X && Y > other.Y)
					{
						return 1;
					}
					else
					{
						return 0;
					}
				}
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Получение хеш-кода вектора
			/// </summary>
			/// <returns>Хеш-код вектора</returns>
			//---------------------------------------------------------------------------------------------------------
			public override Int32 GetHashCode()
			{
				return X.GetHashCode() ^ Y.GetHashCode();
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Полное копирование вектора
			/// </summary>
			/// <returns>Копия вектора</returns>
			//---------------------------------------------------------------------------------------------------------
			public Object Clone()
			{
				return MemberwiseClone();
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Преобразование к текстовому представлению
			/// </summary>
			/// <returns>Текстовое представление вектора с указанием значений координат</returns>
			//---------------------------------------------------------------------------------------------------------
			public override String ToString()
			{
				return String.Format(ToStringFormat, X, Y);
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Преобразование к текстовому представлению
			/// </summary>
			/// <param name="format">Формат отображения</param>
			/// <returns>Текстовое представление вектора с указанием значений координат</returns>
			//---------------------------------------------------------------------------------------------------------
			public String ToString(String format)
			{
				return ("X = " + X.ToString(format) + "; Y = " + Y.ToString(format));
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Преобразование к текстовому представлению
			/// </summary>
			/// <returns>Текстовое представление вектора с указанием значений координат</returns>
			//---------------------------------------------------------------------------------------------------------
			public String ToStringValue()
			{
				return String.Format(ToStringFormatValue, X, Y);
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Преобразование к текстовому представлению
			/// </summary>
			/// <param name="format">Формат отображения компонентов вектора</param>
			/// <returns>Текстовое представление вектора с указанием значений координат</returns>
			//---------------------------------------------------------------------------------------------------------
			public String ToStringValue(String format)
			{
				return String.Format(ToStringFormatValue.Replace("0.00", format), X, Y);
			}
			#endregion

			#region ======================================= ОПЕРАТОРЫ =================================================
			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Сложение векторов
			/// </summary>
			/// <param name="left">Первый вектор</param>
			/// <param name="right">Второй вектор</param>
			/// <returns>Сумма векторов</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Vector2D operator +(Vector2D left, Vector2D right)
			{
				return new Vector2D(left.X + right.X, left.Y + right.Y);
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Вычитание векторов
			/// </summary>
			/// <param name="left">Первый вектор</param>
			/// <param name="right">Второй вектор</param>
			/// <returns>Разность векторов</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Vector2D operator -(Vector2D left, Vector2D right)
			{
				return new Vector2D(left.X - right.X, left.Y - right.Y);
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Умножение вектора на скаляр
			/// </summary>
			/// <param name="vector">Вектор</param>
			/// <param name="scalar">Скаляр</param>
			/// <returns>Масштабированный вектор</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Vector2D operator *(Vector2D vector, Double scalar)
			{
				return new Vector2D(vector.X * scalar, vector.Y * scalar);
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Деление вектора на скаляр
			/// </summary>
			/// <param name="vector">Вектор</param>
			/// <param name="scalar">Скаляр</param>
			/// <returns>Масштабированный вектор</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Vector2D operator /(Vector2D vector, Double scalar)
			{
				scalar = 1 / scalar;
				return new Vector2D(vector.X * scalar, vector.Y * scalar);
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Умножение вектора на вектор. Скалярное произведение векторов
			/// </summary>
			/// <param name="left">Первый вектор</param>
			/// <param name="right">Второй вектор</param>
			/// <returns>Скаляр</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Double operator *(Vector2D left, Vector2D right)
			{
				return left.X * right.X + left.Y * right.Y;
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Умножение вектора на матрицу трансформации
			/// </summary>
			/// <param name="vector">Вектор</param>
			/// <param name="matrix">Матрица трансформации</param>
			/// <returns>Трансформированный вектор</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Vector2D operator *(Vector2D vector, Matrix3Dx2f matrix)
			{
				return new Vector2D(vector.X * matrix.M11 + vector.Y * matrix.M21,
					vector.X * matrix.M12 + vector.Y * matrix.M22);
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Умножение вектора на матрицу трансформации
			/// </summary>
			/// <param name="vector">Вектор</param>
			/// <param name="matrix">Матрица трансформации</param>
			/// <returns>Трансформированный вектор</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Vector2D operator *(Vector2D vector, Matrix4Dx4 matrix)
			{
				return new Vector2D(vector.X * matrix.M11 + vector.Y * matrix.M21 + matrix.M41,
					vector.X * matrix.M12 + vector.Y * matrix.M22 + matrix.M42);
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Сравнение векторов на равенство
			/// </summary>
			/// <param name="left">Первый вектор</param>
			/// <param name="right">Второй вектор</param>
			/// <returns>Статус равенства векторов</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Boolean operator ==(Vector2D left, Vector2D right)
			{
				return left.X == right.X && left.Y == right.Y;
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Сравнение векторов на неравенство
			/// </summary>
			/// <param name="left">Первый вектор</param>
			/// <param name="right">Второй вектор</param>
			/// <returns>Статус неравенства векторов</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Boolean operator !=(Vector2D left, Vector2D right)
			{
				return left.X != right.X || left.Y != right.Y;
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Реализация лексикографического порядка отношений векторов
			/// </summary>
			/// <param name="left">Левый вектор</param>
			/// <param name="right">Правый вектор</param>
			/// <returns>Статус меньше</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Boolean operator <(Vector2D left, Vector2D right)
			{
				return left.X < right.X || left.X == right.X && left.Y < right.Y;
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Реализация лексикографического порядка отношений векторов
			/// </summary>
			/// <param name="left">Левый вектор</param>
			/// <param name="right">Правый вектор</param>
			/// <returns>Статус больше</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Boolean operator >(Vector2D left, Vector2D right)
			{
				return left.X > right.X || left.X == right.X && left.Y > right.Y;
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Обратный вектор
			/// </summary>
			/// <param name="vector">Исходный вектор</param>
			/// <returns>Обратный вектор</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Vector2D operator -(Vector2D vector)
			{
				return new Vector2D(-vector.X, -vector.Y);
			}
			#endregion

			#region ======================================= ОПЕРАТОРЫ ПРЕОБРАЗОВАНИЯ ==================================
			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Неявное преобразование в объект типа Vector2Df
			/// </summary>
			/// <param name="vector">Вектор</param>
			/// <returns>Vector2Df</returns>
			//---------------------------------------------------------------------------------------------------------
			public static implicit operator Vector2Df(Vector2D vector)
			{
				return new Vector2Df((Single)vector.X, (Single)vector.Y);
			}

#if (UNITY_2017_1_OR_NEWER)
			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Неявное преобразование в объект типа UnityEngine.Vector2
			/// </summary>
			/// <param name="vector">Вектор</param>
			/// <returns>UnityEngine.Vector2</returns>
			//---------------------------------------------------------------------------------------------------------
			public static implicit operator UnityEngine.Vector2(Vector2D vector)
			{
				return new UnityEngine.Vector2((Single)vector.X, (Single)vector.Y);
			}
#endif

#if USE_WINDOWS
			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Неявное преобразование в объект типа точки WPF
			/// </summary>
			/// <param name="vector">Вектор</param>
			/// <returns>Точка WPF</returns>
			//---------------------------------------------------------------------------------------------------------
			public unsafe static implicit operator System.Windows.Point(Vector2D vector)
			{
				return (*(System.Windows.Point*)&vector);
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Неявное преобразование в объект типа вектора WPF
			/// </summary>
			/// <param name="vector">Вектор</param>
			/// <returns>Вектор WPF</returns>
			//---------------------------------------------------------------------------------------------------------
			public unsafe static implicit operator System.Windows.Vector(Vector2D vector)
			{
				return (*(System.Windows.Vector*)&vector);
			}
#endif
#if USE_SHARPDX
			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Неявное преобразование в объект типа вектора SharpDX
			/// </summary>
			/// <param name="vector">Вектор</param>
			/// <returns>Вектор SharpDX</returns>
			//---------------------------------------------------------------------------------------------------------
			public static implicit operator global::SharpDX.Vector2(Vector2D vector)
			{
				return (new global::SharpDX.Vector2((Single)vector.X, (Single)vector.Y));
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Неявное преобразование в объект типа вектора SharpDX
			/// </summary>
			/// <param name="vector">Вектор</param>
			/// <returns>Вектор SharpDX</returns>
			//---------------------------------------------------------------------------------------------------------
			public static implicit operator global::SharpDX.Mathematics.Interop.RawVector2(Vector2D vector)
			{
				return (new global::SharpDX.Mathematics.Interop.RawVector2((Single)vector.X, (Single)vector.Y));
			}
#endif
			#endregion

			#region ======================================= ИНДЕКСАТОР ================================================
			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Индексация компонентов вектора на основе индекса
			/// </summary>
			/// <param name="index">Индекс компонента</param>
			/// <returns>Компонента вектора</returns>
			//---------------------------------------------------------------------------------------------------------
			public Double this[Int32 index]
			{
				get
				{
					switch (index)
					{
						case 0:
							return X;
						default:
							return Y;
					}
				}
				set
				{
					switch (index)
					{
						case 0:
							X = value;
							break;
						default:
							Y = value;
							break;
					}
				}
			}
			#endregion

			#region ======================================= ОБЩИЕ МЕТОДЫ ==============================================
			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Нормализация вектора
			/// </summary>
			//---------------------------------------------------------------------------------------------------------
			public void Normalize()
			{
				Double inv_lentgh = XMath.InvSqrt(X * X + Y * Y);
				X *= inv_lentgh;
				Y *= inv_lentgh;
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Вычисление расстояние до вектора
			/// </summary>
			/// <param name="vector">Вектор</param>
			/// <returns>Расстояние до вектора</returns>
			//---------------------------------------------------------------------------------------------------------
			public Double Distance(Vector2D vector)
			{
				Double x = vector.X - X;
				Double y = vector.Y - Y;

				return Math.Sqrt(x * x + y * y);
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Вычисление скалярного произведения векторов
			/// </summary>
			/// <param name="vector">Вектор</param>
			/// <returns>Скалярное произведение векторов</returns>
			//---------------------------------------------------------------------------------------------------------
			public Double Dot(Vector2D vector)
			{
				return X * vector.X + Y * vector.Y;
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Установка компонентов вектора из наибольших компонентов двух векторов
			/// </summary>
			/// <param name="a">Первый вектор</param>
			/// <param name="b">Второй вектор</param>
			//---------------------------------------------------------------------------------------------------------
			public void SetMaximize(Vector2D a, Vector2D b)
			{
				X = a.X > b.X ? a.X : b.X;
				Y = a.Y > b.Y ? a.Y : b.Y;
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Установка компонентов вектора из наименьших компонентов двух векторов
			/// </summary>
			/// <param name="a">Первый вектор</param>
			/// <param name="b">Второй вектор</param>
			//---------------------------------------------------------------------------------------------------------
			public void SetMinimize(Vector2D a, Vector2D b)
			{
				X = a.X < b.X ? a.X : b.X;
				Y = a.Y < b.Y ? a.Y : b.Y;
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Трансформация вектора как точки
			/// </summary>
			/// <param name="matrix">Матрица трансформации</param>
			//---------------------------------------------------------------------------------------------------------
			public void TransformAsPoint(Matrix4Dx4 matrix)
			{
				this = new Vector2D(X * matrix.M11 + Y * matrix.M21 + matrix.M41,
									X * matrix.M12 + Y * matrix.M22 + matrix.M42);
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Трансформация вектора как вектора
			/// </summary>
			/// <param name="matrix">Матрица трансформации</param>
			//---------------------------------------------------------------------------------------------------------
			public void TransformAsVector(Matrix4Dx4 matrix)
			{
				this = new Vector2D(X * matrix.M11 + Y * matrix.M21,
									X * matrix.M12 + Y * matrix.M22);
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Возвращение перпендикулярного вектора расположенного против часовой стрелки
			/// </summary>
			/// <returns>Перпендикулярный вектор</returns>
			//---------------------------------------------------------------------------------------------------------
			public Vector2D PerpToCCW()
			{
				return new Vector2D(-Y, X);
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Возвращение перпендикулярного вектора расположенного по часовой стрелки
			/// </summary>
			/// <returns>Перпендикулярный вектор</returns>
			//---------------------------------------------------------------------------------------------------------
			public Vector2D PerpToCW()
			{
				return new Vector2D(Y, -X);
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Возвращение единичного перпендикулярного вектора расположенного против часовой стрелки
			/// </summary>
			/// <returns>Перпендикулярный вектор</returns>
			//---------------------------------------------------------------------------------------------------------
			public Vector2D UnitPerpToCCW()
			{
				return new Vector2D(-Y, X) / Length;
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Возвращение единичного перпендикулярного вектора расположенного по часовой стрелки
			/// </summary>
			/// <returns>Перпендикулярный вектор</returns>
			//---------------------------------------------------------------------------------------------------------
			public Vector2D UnitPerpToCW()
			{
				return new Vector2D(Y, -X) / Length;
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Возвращение скалярного произведения с перпендикулярным вектором
			/// </summary>
			/// <param name="vector">Вектор</param>
			/// <returns>Скалярное произведение с перпендикулярным вектором</returns>
			//---------------------------------------------------------------------------------------------------------
			public Double DotPerp(Vector2D vector)
			{
				return X * vector.Y - Y * vector.X;
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Сериализация вектора в строку
			/// </summary>
			/// <returns>Строка данных</returns>
			//---------------------------------------------------------------------------------------------------------
			public String SerializeToString()
			{
				return String.Format("{0};{1}", X, Y);
			}
			#endregion

			#region ======================================= МЕТОДЫ ПРЕОБРАЗОВАНИЙ =====================================
			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Преобразование в вектор нулевой X компонентой
			/// </summary>
			/// <returns>Вектор</returns>
			//---------------------------------------------------------------------------------------------------------
			public Vector2D ToVector2X()
			{
				return new Vector2D(X, 0);
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Преобразование в вектор нулевой Y компонентой
			/// </summary>
			/// <returns>Вектор</returns>
			//---------------------------------------------------------------------------------------------------------
			public Vector2D ToVector2Y()
			{
				return new Vector2D(0, Y);
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Преобразование в трехмерный вектор плоскости XY
			/// </summary>
			/// <returns>Вектор</returns>
			//---------------------------------------------------------------------------------------------------------
			public Vector3D ToVector3XY()
			{
				return new Vector3D(X, Y, 0);
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Преобразование в трехмерный вектор плоскости YZ
			/// </summary>
			/// <returns>Вектор</returns>
			//---------------------------------------------------------------------------------------------------------
			public Vector3D ToVector3XZ()
			{
				return new Vector3D(X, 0, Y);
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Преобразование в трехмерный вектор плоскости YZ
			/// </summary>
			/// <returns>Вектор</returns>
			//---------------------------------------------------------------------------------------------------------
			public Vector3D ToVector3YZ()
			{
				return new Vector3D(0, X, Y);
			}
			#endregion
		}

		//-------------------------------------------------------------------------------------------------------------
		/// <summary>
		/// Двухмерный вектор
		/// </summary>
		/// <remarks>
		/// Реализация двухмерного вектора, представляющего собой базовую математическую сущность в двухмерном пространстве
		/// </remarks>
		//-------------------------------------------------------------------------------------------------------------
		[Serializable]
		[StructLayout(LayoutKind.Sequential, Pack = 4)]
		public struct Vector2Df : IEquatable<Vector2Df>, IComparable<Vector2Df>, ICloneable
		{
			#region ======================================= КОНСТАНТНЫЕ ДАННЫЕ ========================================
			/// <summary>
			/// Единичный вектор
			/// </summary>
			public static readonly Vector2Df One = new Vector2Df(1, 1);

			/// <summary>
			/// Вектор "право"
			/// </summary>
			public static readonly Vector2Df Right = new Vector2Df(1, 0);

			/// <summary>
			/// Вектор "влево"
			/// </summary>
			public static readonly Vector2Df Left = new Vector2Df(-1, 0);

			/// <summary>
			/// Вектор "вверх"
			/// </summary>
			public static readonly Vector2Df Up = new Vector2Df(0, 1);

			/// <summary>
			/// Вектор "вниз"
			/// </summary>
			public static readonly Vector2Df Down = new Vector2Df(0, -1);

			/// <summary>
			/// Нулевой вектор
			/// </summary>
			public static readonly Vector2Df Zero = new Vector2Df(0, 0);
			#endregion

			#region ======================================= СТАТИЧЕСКИЕ ДАННЫЕ ========================================
			/// <summary>
			/// Текстовый формат отображения параметров вектора
			/// </summary>
			public static String ToStringFormat = "X = {0:0.00}; Y = {1:0.00}";
			#endregion

			#region ======================================= СТАТИЧЕСКИЕ МЕТОДЫ ========================================
			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Косинус угла между векторами
			/// </summary>
			/// <param name="from">Начальный вектор</param>
			/// <param name="to">Конечный вектор</param>
			/// <returns>Косинус угла</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Single Cos(ref Vector2Df from, ref Vector2Df to)
			{
				Single dot = from.X * to.X + from.Y * to.Y;
				Single ll = from.Length * to.Length;
				return dot / ll;
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Косинус угла между векторами
			/// </summary>
			/// <param name="from">Начальный вектор</param>
			/// <param name="to">Конечный вектор</param>
			/// <returns>Косинус угла</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Single Cos(Vector2Df from, Vector2Df to)
			{
				Single dot = from.X * to.X + from.Y * to.Y;
				Single ll = from.Length * to.Length;
				return dot / ll;
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Угол между двумя векторами (в градусах)
			/// </summary>
			/// <param name="from">Начальный вектор</param>
			/// <param name="to">Конечные вектор</param>
			/// <returns>Угол в градусах</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Single Angle(ref Vector2Df from, ref Vector2Df to)
			{
				Single dot = from.X * to.X + from.Y * to.Y;
				Single ll = from.Length * to.Length;
				Single csv = dot / ll;
				return (Single)(Math.Acos(csv) * XMath.RadianToDegree_d);
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Угол между двумя векторами (в градусах)
			/// </summary>
			/// <param name="from">Начальный вектор</param>
			/// <param name="to">Конечные вектор</param>
			/// <returns>Угол в градусах</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Single Angle(Vector2Df from, Vector2Df to)
			{
				Single dot = from.X * to.X + from.Y * to.Y;
				Single ll = from.Length * to.Length;
				Single csv = dot / ll;
				return (Single)(Math.Acos(csv) * XMath.RadianToDegree_d);
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Расстояние между двумя векторами
			/// </summary>
			/// <param name="a">Первый вектор</param>
			/// <param name="b">Второй вектор</param>
			/// <returns>Расстояние между двумя векторами</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Single Distance(ref Vector2Df a, ref Vector2Df b)
			{
				Single x = b.X - a.X;
				Single y = b.Y - a.Y;

				return (Single)Math.Sqrt(x * x + y * y);
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Расстояние между двумя векторами
			/// </summary>
			/// <param name="a">Первый вектор</param>
			/// <param name="b">Второй вектор</param>
			/// <returns>Расстояние между двумя векторами</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Single Distance(Vector2Df a, Vector2Df b)
			{
				Single x = b.X - a.X;
				Single y = b.Y - a.Y;

				return (Single)Math.Sqrt(x * x + y * y);
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Скалярное произведение векторов
			/// </summary>
			/// <param name="a">Первый вектор</param>
			/// <param name="b">Второй вектор</param>
			/// <returns>Скаляр</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Single Dot(ref Vector2Df a, ref Vector2Df b)
			{
				return a.X * b.X + a.Y * b.Y;
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Скалярное произведение векторов
			/// </summary>
			/// <param name="a">Первый вектор</param>
			/// <param name="b">Второй вектор</param>
			/// <returns>Скаляр</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Single Dot(Vector2Df a, Vector2Df b)
			{
				return a.X * b.X + a.Y * b.Y;
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Возвращение скалярного произведения с перпендикулярным вектором
			/// </summary>
			/// <param name="a">Первый вектор</param>
			/// <param name="b">Второй вектор</param>
			/// <returns>Скалярное произведение с перпендикулярным вектором</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Single DotPerp(ref Vector2Df a, ref Vector2Df b)
			{
				return a.X * b.Y - a.Y * b.X;
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Возвращение скалярного произведения с перпендикулярным вектором
			/// </summary>
			/// <param name="a">Первый вектор</param>
			/// <param name="b">Второй вектор</param>
			/// <returns>Скалярное произведение с перпендикулярным вектором</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Single DotPerp(Vector2Df a, Vector2Df b)
			{
				return a.X * b.Y - a.Y * b.X;
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Линейная интерполяция векторов
			/// </summary>
			/// <param name="from">Начальный вектор</param>
			/// <param name="to">Конечный вектор</param>
			/// <param name="time">Время от 0 до 1</param>
			/// <returns>Интерполированный вектор</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Vector2Df Lerp(ref Vector2Df from, ref Vector2Df to, Single time)
			{
				Vector2Df vector;
				vector.X = from.X + (to.X - from.X) * time;
				vector.Y = from.Y + (to.Y - from.Y) * time;
				return vector;
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Негативное значение для вектора
			/// </summary>
			/// <param name="value">Исходный вектор</param>
			/// <returns>Негативный вектор</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Vector2Df Negate(ref Vector2Df value)
			{
				return new Vector2Df(-value.X, -value.Y);
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Максимальное значение из компонентов векторов
			/// </summary>
			/// <param name="a">Первый вектор</param>
			/// <param name="b">Второй вектор</param>
			/// <param name="result">Результирующий вектор</param>
			//---------------------------------------------------------------------------------------------------------
			public static void Max(ref Vector2Df a, ref Vector2Df b, out Vector2Df result)
			{
				result.X = a.X > b.X ? a.X : b.X;
				result.Y = a.Y > b.Y ? a.Y : b.Y;
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Максимальное значение из компонентов векторов
			/// </summary>
			/// <param name="a">Первый вектор</param>
			/// <param name="b">Второй вектор</param>
			/// <returns>Результирующий вектор</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Vector2Df Max(ref Vector2Df a, ref Vector2Df b)
			{
				return new Vector2Df(a.X > b.X ? a.X : b.X, a.Y > b.Y ? a.Y : b.Y);
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Минимальное значение из компонентов векторов
			/// </summary>
			/// <param name="a">Первый вектор</param>
			/// <param name="b">Второй вектор</param>
			/// <param name="result">Результирующий вектор</param>
			//---------------------------------------------------------------------------------------------------------
			public static void Min(ref Vector2Df a, ref Vector2Df b, out Vector2Df result)
			{
				result.X = a.X < b.X ? a.X : b.X;
				result.Y = a.Y < b.Y ? a.Y : b.Y;
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Минимальное значение из компонентов векторов
			/// </summary>
			/// <param name="a">Первый вектор</param>
			/// <param name="b">Второй вектор</param>
			/// <returns>Результирующий вектор</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Vector2Df Min(ref Vector2Df a, ref Vector2Df b)
			{
				return new Vector2Df(a.X < b.X ? a.X : b.X, a.Y < b.Y ? a.Y : b.Y);
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Отражение вектора относительно нормали
			/// </summary>
			/// <param name="vector">Исходный вектор</param>
			/// <param name="normal">Вектор нормали</param>
			/// <param name="result">Результирующий вектор</param>
			//---------------------------------------------------------------------------------------------------------
			public static void Reflect(ref Vector2Df vector, ref Vector2Df normal, out Vector2Df result)
			{
				Single dot = vector.X * normal.X + vector.Y * normal.Y;

				result.X = vector.X - 2.0f * dot * normal.X;
				result.Y = vector.Y - 2.0f * dot * normal.Y;
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Отражение вектора относительно нормали
			/// </summary>
			/// <param name="vector">Исходный вектор</param>
			/// <param name="normal">Вектор нормали</param>
			/// <returns>Результирующий вектор</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Vector2Df Reflect(ref Vector2Df vector, ref Vector2Df normal)
			{
				Vector2Df result;
				Reflect(ref vector, ref normal, out result);
				return result;
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Аппроксимация равенства значений векторов
			/// </summary>
			/// <param name="a">Первый вектор</param>
			/// <param name="b">Второй вектор</param>
			/// <param name="epsilon">Погрешность</param>
			/// <returns>Статус равенства значений</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Boolean Approximately(ref Vector2Df a, ref Vector2Df b, Single epsilon = 0.001f)
			{
				if (Math.Abs(a.X - b.X) < epsilon && Math.Abs(a.Y - b.Y) < epsilon)
				{
					return true;
				}

				return false;
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Аппроксимация равенства значений векторов
			/// </summary>
			/// <param name="a">Первый вектор</param>
			/// <param name="b">Второй вектор</param>
			/// <param name="epsilon">Погрешность</param>
			/// <returns>Статус равенства значений</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Boolean Approximately(Vector2Df a, Vector2Df b, Single epsilon = 0.001f)
			{
				if (Math.Abs(a.X - b.X) < epsilon && Math.Abs(a.Y - b.Y) < epsilon)
				{
					return true;
				}

				return false;
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Десереализация двухмерного вектора из строки
			/// </summary>
			/// <param name="data">Строка данных</param>
			/// <returns>Двухмерный вектор</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Vector2Df DeserializeFromString(String data)
			{
				Vector2Df vector = new Vector2Df();
				String[] vector_data = data.Split(';');
				vector.X = XMath.ParseSingle(vector_data[0]);
				vector.Y = XMath.ParseSingle(vector_data[1]);
				return vector;
			}
			#endregion

			#region ======================================= ДАННЫЕ ====================================================
			/// <summary>
			/// Компонента X
			/// </summary>
			public Single X;

			/// <summary>
			/// Компонента Y
			/// </summary>
			public Single Y;
			#endregion

			#region ======================================= СВОЙСТВА ==================================================
			/// <summary>
			/// Квадрат длины вектора
			/// </summary>
			public Single SqrLength
			{
				get { return X * X + Y * Y; }
			}

			/// <summary>
			/// Длина вектора
			/// </summary>
			public Single Length
			{
				get { return (Single)Math.Sqrt(X * X + Y * Y); }
			}

			/// <summary>
			/// Нормализованный вектор
			/// </summary>
			public Vector2Df Normalized
			{
				get
				{
					Single inv_lentgh = XMath.InvSqrt(X * X + Y * Y);
					return new Vector2Df(X * inv_lentgh, Y * inv_lentgh);
				}
			}
			#endregion

			#region ======================================= КОНСТРУКТОРЫ ==============================================
			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Конструктор инициализирует вектор указанными параметрами
			/// </summary>
			/// <param name="x">X - координата</param>
			/// <param name="y">Y - координата</param>
			//---------------------------------------------------------------------------------------------------------
			public Vector2Df(Single x, Single y)
			{
				X = x;
				Y = y;
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Конструктор инициализирует вектор указанным вектором
			/// </summary>
			/// <param name="source">Вектор</param>
			//---------------------------------------------------------------------------------------------------------
			public Vector2Df(Vector2Df source)
			{
				X = source.X;
				Y = source.Y;
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Конструктор инициализирует вектор указанным вектором
			/// </summary>
			/// <param name="source">Вектор</param>
			//---------------------------------------------------------------------------------------------------------
			public Vector2Df(Vector2D source)
			{
				X = (Single)source.X;
				Y = (Single)source.Y;
			}

#if USE_WINDOWS
			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Конструктор инициализирует вектор указанной точкой WPF
			/// </summary>
			/// <param name="source">Точка WPF</param>
			//---------------------------------------------------------------------------------------------------------
			public Vector2Df(System.Windows.Vector source)
			{
				X = (Single)source.X;
				Y = (Single)source.Y;
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Конструктор инициализирует вектор указанной точкой WPF
			/// </summary>
			/// <param name="source">Точка WPF</param>
			//---------------------------------------------------------------------------------------------------------
			public Vector2Df(System.Windows.Point source)
			{
				X = (Single)source.X;
				Y = (Single)source.Y;
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Конструктор инициализирует вектор разностью точек WPF
			/// </summary>
			/// <param name="start">Начальная точка WPF</param>
			/// <param name="end">Конечная точка WPF</param>
			//---------------------------------------------------------------------------------------------------------
			public Vector2Df(System.Windows.Point start, System.Windows.Point end)
			{
				X = (Single)(end.X - start.X);
				Y = (Single)(end.Y - start.Y);
			}
#endif
#if USE_SHARPDX
			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Конструктор инициализирует вектор указанным вектором SharpDX
			/// </summary>
			/// <param name="source">Вектор SharpDX</param>
			//---------------------------------------------------------------------------------------------------------
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			public Vector2Df(global::SharpDX.Vector2 source)
			{
				X = source.X;
				Y = source.Y;
			}
#endif
			#endregion

			#region ======================================= СИСТЕМНЫЕ МЕТОДЫ ==========================================
			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Проверяет равен ли текущий объект другому объекту того же типа
			/// </summary>
			/// <param name="obj">Сравниваемый объект</param>
			/// <returns>Статус равенства объектов</returns>
			//---------------------------------------------------------------------------------------------------------
			public override Boolean Equals(Object obj)
			{
				if (obj != null)
				{
					if (typeof(Vector2Df) == obj.GetType())
					{
						Vector2Df vector = (Vector2Df)obj;
						return Equals(vector);
					}
				}
				return base.Equals(obj);
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Проверка равенства векторов по значению
			/// </summary>
			/// <param name="other">Сравниваемый вектор</param>
			/// <returns>Статус равенства векторов</returns>
			//---------------------------------------------------------------------------------------------------------
			public Boolean Equals(Vector2Df other)
			{
				return this == other;
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Сравнение векторов для упорядочивания
			/// </summary>
			/// <param name="other">Сравниваемый вектор</param>
			/// <returns>Статус сравнения векторов</returns>
			//---------------------------------------------------------------------------------------------------------
			public Int32 CompareTo(Vector2Df other)
			{
				if (X > other.X)
				{
					return 1;
				}
				else
				{
					if (X == other.X && Y > other.Y)
					{
						return 1;
					}
					else
					{
						return 0;
					}
				}
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Получение хеш-кода вектора
			/// </summary>
			/// <returns>Хеш-код вектора</returns>
			//---------------------------------------------------------------------------------------------------------
			public override Int32 GetHashCode()
			{
				return X.GetHashCode() ^ Y.GetHashCode();
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Полное копирование вектора
			/// </summary>
			/// <returns>Копия вектора</returns>
			//---------------------------------------------------------------------------------------------------------
			public Object Clone()
			{
				return MemberwiseClone();
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Преобразование к текстовому представлению
			/// </summary>
			/// <returns>Текстовое представление вектора с указанием значений координат</returns>
			//---------------------------------------------------------------------------------------------------------
			public override String ToString()
			{
				return String.Format(ToStringFormat, X, Y);
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Преобразование к текстовому представлению
			/// </summary>
			/// <param name="format">Формат отображения</param>
			/// <returns>Текстовое представление вектора с указанием значений координат</returns>
			//---------------------------------------------------------------------------------------------------------
			public String ToString(String format)
			{
				return "X = " + X.ToString(format) + "; Y = " + Y.ToString(format);
			}
			#endregion

			#region ======================================= ОПЕРАТОРЫ =================================================
			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Сложение векторов
			/// </summary>
			/// <param name="left">Первый вектор</param>
			/// <param name="right">Второй вектор</param>
			/// <returns>Сумма векторов</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Vector2Df operator +(Vector2Df left, Vector2Df right)
			{
				return new Vector2Df(left.X + right.X, left.Y + right.Y);
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Вычитание векторов
			/// </summary>
			/// <param name="left">Первый вектор</param>
			/// <param name="right">Второй вектор</param>
			/// <returns>Разность векторов</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Vector2Df operator -(Vector2Df left, Vector2Df right)
			{
				return new Vector2Df(left.X - right.X, left.Y - right.Y);
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Умножение вектора на скаляр
			/// </summary>
			/// <param name="vector">Вектор</param>
			/// <param name="scalar">Скаляр</param>
			/// <returns>Масштабированный вектор</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Vector2Df operator *(Vector2Df vector, Single scalar)
			{
				return new Vector2Df(vector.X * scalar, vector.Y * scalar);
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Деление вектора на скаляр
			/// </summary>
			/// <param name="vector">Вектор</param>
			/// <param name="scalar">Скаляр</param>
			/// <returns>Масштабированный вектор</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Vector2Df operator /(Vector2Df vector, Single scalar)
			{
				scalar = 1 / scalar;
				return new Vector2Df(vector.X * scalar, vector.Y * scalar);
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Умножение вектора на вектор. Скалярное произведение векторов
			/// </summary>
			/// <param name="left">Первый вектор</param>
			/// <param name="right">Второй вектор</param>
			/// <returns>Скаляр</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Single operator *(Vector2Df left, Vector2Df right)
			{
				return left.X * right.X + left.Y * right.Y;
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Умножение вектора на матрицу трансформации
			/// </summary>
			/// <param name="vector">Вектор</param>
			/// <param name="matrix">Матрица трансформации</param>
			/// <returns>Трансформированный вектор</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Vector2Df operator *(Vector2Df vector, Matrix3Dx2f matrix)
			{
				return new Vector2Df((Single)(vector.X * matrix.M11 + vector.Y * matrix.M21),
					(Single)(vector.X * matrix.M12 + vector.Y * matrix.M22));
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Умножение вектора на матрицу трансформации
			/// </summary>
			/// <param name="vector">Вектор</param>
			/// <param name="matrix">Матрица трансформации</param>
			/// <returns>Трансформированный вектор</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Vector2Df operator *(Vector2Df vector, Matrix4Dx4 matrix)
			{
				return new Vector2Df((Single)(vector.X * matrix.M11 + vector.Y * matrix.M21 + matrix.M41),
					(Single)(vector.X * matrix.M12 + vector.Y * matrix.M22 + matrix.M42));
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Сравнение векторов на равенство
			/// </summary>
			/// <param name="left">Первый вектор</param>
			/// <param name="right">Второй вектор</param>
			/// <returns>Статус равенства векторов</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Boolean operator ==(Vector2Df left, Vector2Df right)
			{
				return left.X == right.X && left.Y == right.Y;
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Сравнение векторов на неравенство
			/// </summary>
			/// <param name="left">Первый вектор</param>
			/// <param name="right">Второй вектор</param>
			/// <returns>Статус неравенства векторов</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Boolean operator !=(Vector2Df left, Vector2Df right)
			{
				return left.X != right.X || left.Y != right.Y;
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Реализация лексикографического порядка отношений векторов
			/// </summary>
			/// <param name="left">Левый вектор</param>
			/// <param name="right">Правый вектор</param>
			/// <returns>Статус меньше</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Boolean operator <(Vector2Df left, Vector2Df right)
			{
				return left.X < right.X || left.X == right.X && left.Y < right.Y;
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Реализация лексикографического порядка отношений векторов
			/// </summary>
			/// <param name="left">Левый вектор</param>
			/// <param name="right">Правый вектор</param>
			/// <returns>Статус больше</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Boolean operator >(Vector2Df left, Vector2Df right)
			{
				return left.X > right.X || left.X == right.X && left.Y > right.Y;
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Обратный вектор
			/// </summary>
			/// <param name="vector">Исходный вектор</param>
			/// <returns>Обратный вектор</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Vector2Df operator -(Vector2Df vector)
			{
				return new Vector2Df(-vector.X, -vector.Y);
			}
			#endregion

			#region ======================================= ОПЕРАТОРЫ ПРЕОБРАЗОВАНИЯ ==================================
#if (UNITY_2017_1_OR_NEWER)
			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Неявное преобразование в объект типа <see cref="UnityEngine.Vector2"/> 
			/// </summary>
			/// <param name="vector">Вектор</param>
			/// <returns>Объект <see cref="UnityEngine.Vector2"/> </returns>
			//---------------------------------------------------------------------------------------------------------
			public static implicit operator UnityEngine.Vector2(Vector2Df vector)
			{
				return new UnityEngine.Vector2(vector.X, vector.Y);
			}
#endif

#if USE_WINDOWS
			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Неявное преобразование в объект типа точки WPF
			/// </summary>
			/// <param name="vector">Вектор</param>
			/// <returns>Точка WPF</returns>
			//---------------------------------------------------------------------------------------------------------
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			public static implicit operator System.Windows.Point(Vector2Df vector)
			{
				return (new System.Windows.Point(vector.X, vector.Y));
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Неявное преобразование в объект типа вектора WPF
			/// </summary>
			/// <param name="vector">Вектор</param>
			/// <returns>Вектор WPF</returns>
			//---------------------------------------------------------------------------------------------------------
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			public static implicit operator System.Windows.Vector(Vector2Df vector)
			{
				return (new System.Windows.Vector(vector.X, vector.Y));
			}
#endif
#if USE_GDI
			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Неявное преобразование в объект типа точки System.Drawing
			/// </summary>
			/// <param name="vector">Вектор</param>
			/// <returns>Точка System.Drawing</returns>
			//---------------------------------------------------------------------------------------------------------
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			public static implicit operator System.Drawing.Point(Vector2Df vector)
			{
				return (new System.Drawing.Point((Int32)vector.X, (Int32)vector.Y));
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Неявное преобразование в объект типа точки System.Drawing
			/// </summary>
			/// <param name="vector">Вектор</param>
			/// <returns>Точка System.Drawing</returns>
			//---------------------------------------------------------------------------------------------------------
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			public static implicit operator System.Drawing.PointF(Vector2Df vector)
			{
				return (new System.Drawing.PointF(vector.X, vector.Y));
			}
#endif
#if USE_SHARPDX
			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Неявное преобразование в объект типа вектора SharpDX
			/// </summary>
			/// <param name="vector">Вектор</param>
			/// <returns>Вектор SharpDX</returns>
			//---------------------------------------------------------------------------------------------------------
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			public unsafe static implicit operator SharpDX.Vector2(Vector2Df vector)
			{
				return (*(SharpDX.Vector2*)&vector);
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Неявное преобразование в объект типа вектора SharpDX
			/// </summary>
			/// <param name="vector">Вектор</param>
			/// <returns>Вектор SharpDX</returns>
			//---------------------------------------------------------------------------------------------------------
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			public unsafe static implicit operator SharpDX.Mathematics.Interop.RawVector2(Vector2Df vector)
			{
				return (*(SharpDX.Mathematics.Interop.RawVector2*)&vector);
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Неявное преобразование в объект типа вектора SharpDX
			/// </summary>
			/// <param name="vector">Вектор</param>
			/// <returns>Вектор SharpDX</returns>
			//---------------------------------------------------------------------------------------------------------
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			public unsafe static implicit operator Vector2Df(SharpDX.Vector2 vector)
			{
				return (*(Vector2Df*)&vector);
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Неявное преобразование в объект типа вектора SharpDX
			/// </summary>
			/// <param name="vector">Вектор</param>
			/// <returns>Вектор SharpDX</returns>
			//---------------------------------------------------------------------------------------------------------
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			public unsafe static implicit operator Vector2Df(SharpDX.Mathematics.Interop.RawVector2 vector)
			{
				return (*(Vector2Df*)&vector);
			}
#endif
			#endregion

			#region ======================================= ИНДЕКСАТОР ================================================
			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Индексация компонентов вектора на основе индекса
			/// </summary>
			/// <param name="index">Индекс компонента</param>
			/// <returns>Компонента вектора</returns>
			//---------------------------------------------------------------------------------------------------------
			public Single this[Int32 index]
			{
				get
				{
					switch (index)
					{
						case 0:
							return X;
						default:
							return Y;
					}
				}
				set
				{
					switch (index)
					{
						case 0:
							X = value;
							break;
						default:
							Y = value;
							break;
					}
				}
			}
			#endregion

			#region ======================================= ОБЩИЕ МЕТОДЫ ==============================================
			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Нормализация вектора
			/// </summary>
			//---------------------------------------------------------------------------------------------------------
			public void Normalize()
			{
				Single inv_lentgh = XMath.InvSqrt(X * X + Y * Y);
				X *= inv_lentgh;
				Y *= inv_lentgh;
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Смещение вектора
			/// </summary>
			/// <param name="x">Смещение по X</param>
			/// <param name="y">Смещение по Y</param>
			//---------------------------------------------------------------------------------------------------------
			public void Offset(Single x, Single y)
			{
				X += x;
				Y += y;
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Вычисление расстояние до вектора
			/// </summary>
			/// <param name="vector">Вектор</param>
			/// <returns>Расстояние до вектора</returns>
			//---------------------------------------------------------------------------------------------------------
			public Single Distance(Vector2Df vector)
			{
				Single x = vector.X - X;
				Single y = vector.Y - Y;

				return (Single)Math.Sqrt(x * x + y * y);
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Вычисление скалярного произведения векторов
			/// </summary>
			/// <param name="vector">Вектор</param>
			/// <returns>Скалярное произведение векторов</returns>
			//---------------------------------------------------------------------------------------------------------
			public Single Dot(Vector2Df vector)
			{
				return X * vector.X + Y * vector.Y;
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Установка компонентов вектора из наибольших компонентов двух векторов
			/// </summary>
			/// <param name="a">Первый вектор</param>
			/// <param name="b">Второй вектор</param>
			//---------------------------------------------------------------------------------------------------------
			public void SetMaximize(Vector2Df a, Vector2Df b)
			{
				X = a.X > b.X ? a.X : b.X;
				Y = a.Y > b.Y ? a.Y : b.Y;
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Установка компонентов вектора из наименьших компонентов двух векторов
			/// </summary>
			/// <param name="a">Первый вектор</param>
			/// <param name="b">Второй вектор</param>
			//---------------------------------------------------------------------------------------------------------
			public void SetMinimize(Vector2Df a, Vector2Df b)
			{
				X = a.X < b.X ? a.X : b.X;
				Y = a.Y < b.Y ? a.Y : b.Y;
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Трансформация вектора как точки
			/// </summary>
			/// <param name="matrix">Матрица трансформации</param>
			//---------------------------------------------------------------------------------------------------------
			public void TransformAsPoint(Matrix3Dx2f matrix)
			{
				this = new Vector2Df(X * matrix.M11 + Y * matrix.M21 + matrix.M31,
									X * matrix.M12 + Y * matrix.M22 + matrix.M31);
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Трансформация вектора как точки
			/// </summary>
			/// <param name="matrix">Матрица трансформации</param>
			//---------------------------------------------------------------------------------------------------------
			public void TransformAsPoint(Matrix4Dx4 matrix)
			{
				this = new Vector2Df((Single)(X * matrix.M11 + Y * matrix.M21 + matrix.M41),
									(Single)(X * matrix.M12 + Y * matrix.M22 + matrix.M42));
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Трансформация вектора как вектора
			/// </summary>
			/// <param name="matrix">Матрица трансформации</param>
			//---------------------------------------------------------------------------------------------------------
			public void TransformAsVector(Matrix3Dx2f matrix)
			{
				this = new Vector2Df(X * matrix.M11 + Y * matrix.M21,
									X * matrix.M12 + Y * matrix.M22);
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Трансформация вектора как вектора
			/// </summary>
			/// <param name="matrix">Матрица трансформации</param>
			//---------------------------------------------------------------------------------------------------------
			public void TransformAsVector(Matrix4Dx4 matrix)
			{
				this = new Vector2Df((Single)(X * matrix.M11 + Y * matrix.M21),
									(Single)(X * matrix.M12 + Y * matrix.M22));
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Возвращение перпендикулярного вектора расположенного против часовой стрелки
			/// </summary>
			/// <returns>Перпендикулярный вектор</returns>
			//---------------------------------------------------------------------------------------------------------
			public Vector2Df PerpToCCW()
			{
				return new Vector2Df(-Y, X);
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Возвращение перпендикулярного вектора расположенного по часовой стрелки
			/// </summary>
			/// <returns>Перпендикулярный вектор</returns>
			//---------------------------------------------------------------------------------------------------------
			public Vector2Df PerpToCW()
			{
				return new Vector2Df(Y, -X);
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Возвращение единичного перпендикулярного вектора расположенного против часовой стрелки
			/// </summary>
			/// <returns>Перпендикулярный вектор</returns>
			//---------------------------------------------------------------------------------------------------------
			public Vector2Df UnitPerpToCCW()
			{
				return new Vector2Df(-Y, X) / Length;
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Возвращение единичного перпендикулярного вектора расположенного по часовой стрелки
			/// </summary>
			/// <returns>Перпендикулярный вектор</returns>
			//---------------------------------------------------------------------------------------------------------
			public Vector2Df UnitPerpToCW()
			{
				return new Vector2Df(Y, -X) / Length;
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Возвращение скалярного произведения с перпендикулярным вектором
			/// </summary>
			/// <param name="vector">Вектор</param>
			/// <returns>Скалярное произведение с перпендикулярным вектором</returns>
			//---------------------------------------------------------------------------------------------------------
			public Single DotPerp(Vector2Df vector)
			{
				// x*V.y - y*V.x.
				return X * vector.Y - Y * vector.X;
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Возвращение скалярного произведения с перпендикулярным вектором
			/// </summary>
			/// <param name="vector">Вектор</param>
			/// <returns>Скалярное произведение с перпендикулярным вектором</returns>
			//---------------------------------------------------------------------------------------------------------
			public Single DotPerp(ref Vector2Df vector)
			{
				// x*V.y - y*V.x.
				return X * vector.Y - Y * vector.X;
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Сериализация вектора в строку
			/// </summary>
			/// <returns>Строка данных</returns>
			//---------------------------------------------------------------------------------------------------------
			public String SerializeToString()
			{
				return String.Format("{0};{1}", X, Y);
			}
			#endregion

			#region ======================================= МЕТОДЫ ПРЕОБРАЗОВАНИЙ =====================================
			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Преобразование в вектор нулевой X компонентой
			/// </summary>
			/// <returns>Вектор</returns>
			//---------------------------------------------------------------------------------------------------------
			public Vector2Df ToVector2X()
			{
				return new Vector2Df(X, 0);
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Преобразование в вектор нулевой Y компонентой
			/// </summary>
			/// <returns>Вектор</returns>
			//---------------------------------------------------------------------------------------------------------
			public Vector2Df ToVector2Y()
			{
				return new Vector2Df(0, Y);
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Преобразование в трехмерный вектор плоскости XY
			/// </summary>
			/// <returns>Вектор</returns>
			//---------------------------------------------------------------------------------------------------------
			public Vector3Df ToVector3XY()
			{
				return new Vector3Df(X, Y, 0);
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Преобразование в трехмерный вектор плоскости YZ
			/// </summary>
			/// <returns>Вектор</returns>
			//---------------------------------------------------------------------------------------------------------
			public Vector3Df ToVector3XZ()
			{
				return new Vector3Df(X, 0, Y);
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Преобразование в трехмерный вектор плоскости YZ
			/// </summary>
			/// <returns>Вектор</returns>
			//---------------------------------------------------------------------------------------------------------
			public Vector3Df ToVector3YZ()
			{
				return new Vector3Df(0, X, Y);
			}
			#endregion
		}

		//-------------------------------------------------------------------------------------------------------------
		/// <summary>
		/// Двухмерный вектор
		/// </summary>
		/// <remarks>
		/// Реализация двухмерного вектора, представляющего собой базовую математическую сущность в двухмерном пространстве
		/// </remarks>
		//-------------------------------------------------------------------------------------------------------------
		[Serializable]
		[StructLayout(LayoutKind.Sequential, Pack = 4)]
		public struct Vector2Di : IEquatable<Vector2Di>, IComparable<Vector2Di>, ICloneable
		{
			#region ======================================= КОНСТАНТНЫЕ ДАННЫЕ ========================================
			/// <summary>
			/// Единичный вектор
			/// </summary>
			public static readonly Vector2Di One = new Vector2Di(1, 1);

			/// <summary>
			/// Вектор "право"
			/// </summary>
			public static readonly Vector2Di Right = new Vector2Di(1, 0);

			/// <summary>
			/// Вектор "влево"
			/// </summary>
			public static readonly Vector2Di Left = new Vector2Di(-1, 0);

			/// <summary>
			/// Вектор "вверх"
			/// </summary>
			public static readonly Vector2Di Up = new Vector2Di(0, 1);

			/// <summary>
			/// Вектор "вниз"
			/// </summary>
			public static readonly Vector2Di Down = new Vector2Di(0, -1);

			/// <summary>
			/// Нулевой вектор
			/// </summary>
			public static readonly Vector2Di Zero = new Vector2Di(0, 0);
			#endregion

			#region ======================================= СТАТИЧЕСКИЕ ДАННЫЕ ========================================
			/// <summary>
			/// Текстовый формат отображения параметров вектора
			/// </summary>
			public static String ToStringFormat = "X = {0}; Y = {1}";
			#endregion

			#region ======================================= СТАТИЧЕСКИЕ МЕТОДЫ ========================================
			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Косинус угла между векторами
			/// </summary>
			/// <param name="from">Начальный вектор</param>
			/// <param name="to">Конечный вектор</param>
			/// <returns>Косинус угла</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Single Cos(ref Vector2Di from, ref Vector2Di to)
			{
				Single dot = from.X * to.X + from.Y * to.Y;
				Single ll = from.Length * to.Length;
				return dot / ll;
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Угол между двумя векторами (в градусах)
			/// </summary>
			/// <param name="from">Начальный вектор</param>
			/// <param name="to">Конечные вектор</param>
			/// <returns>Угол в градусах</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Single Angle(ref Vector2Di from, ref Vector2Di to)
			{
				Single dot = from.X * to.X + from.Y * to.Y;
				Single ll = from.Length * to.Length;
				Single csv = dot / ll;
				return (Int32)(Math.Acos(csv) * XMath.RadianToDegree_d);
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Расстояние между двумя векторами
			/// </summary>
			/// <param name="a">Первый вектор</param>
			/// <param name="b">Второй вектор</param>
			/// <returns>Расстояние между двумя векторами</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Single Distance(ref Vector2Di a, ref Vector2Di b)
			{
				Single x = b.X - a.X;
				Single y = b.Y - a.Y;

				return (Single)Math.Sqrt(x * x + y * y);
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Скалярное произведение векторов
			/// </summary>
			/// <param name="a">Первый вектор</param>
			/// <param name="b">Второй вектор</param>
			/// <returns>Скаляр</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Single Dot(ref Vector2Di a, ref Vector2Di b)
			{
				return a.X * b.X + a.Y * b.Y;
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Линейная интерполяция векторов
			/// </summary>
			/// <param name="from">Начальный вектор</param>
			/// <param name="to">Конечный вектор</param>
			/// <param name="time">Время от 0 до 1</param>
			/// <returns>Интерполированный вектор</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Vector2Di Lerp(ref Vector2Di from, ref Vector2Di to, Single time)
			{
				Vector2Di vector;
				vector.X = (Int32)(from.X + (to.X - from.X) * time);
				vector.Y = (Int32)(from.Y + (to.Y - from.Y) * time);
				return vector;
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Негативное значение для вектора
			/// </summary>
			/// <param name="value">Исходный вектор</param>
			/// <returns>Негативный вектор</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Vector2Di Negate(ref Vector2Di value)
			{
				return new Vector2Di(-value.X, -value.Y);
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Максимальное значение из компонентов векторов
			/// </summary>
			/// <param name="a">Первый вектор</param>
			/// <param name="b">Второй вектор</param>
			/// <param name="result">Результирующий вектор</param>
			//---------------------------------------------------------------------------------------------------------
			public static void Max(ref Vector2Di a, ref Vector2Di b, out Vector2Di result)
			{
				result.X = a.X > b.X ? a.X : b.X;
				result.Y = a.Y > b.Y ? a.Y : b.Y;
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Максимальное значение из компонентов векторов
			/// </summary>
			/// <param name="a">Первый вектор</param>
			/// <param name="b">Второй вектор</param>
			/// <returns>Результирующий вектор</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Vector2Di Max(ref Vector2Di a, ref Vector2Di b)
			{
				return new Vector2Di(a.X > b.X ? a.X : b.X, a.Y > b.Y ? a.Y : b.Y);
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Минимальное значение из компонентов векторов
			/// </summary>
			/// <param name="a">Первый вектор</param>
			/// <param name="b">Второй вектор</param>
			/// <param name="result">Результирующий вектор</param>
			//---------------------------------------------------------------------------------------------------------
			public static void Min(ref Vector2Di a, ref Vector2Di b, out Vector2Di result)
			{
				result.X = a.X < b.X ? a.X : b.X;
				result.Y = a.Y < b.Y ? a.Y : b.Y;
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Минимальное значение из компонентов векторов
			/// </summary>
			/// <param name="a">Первый вектор</param>
			/// <param name="b">Второй вектор</param>
			/// <returns>Результирующий вектор</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Vector2Di Min(ref Vector2Di a, ref Vector2Di b)
			{
				return new Vector2Di(a.X < b.X ? a.X : b.X, a.Y < b.Y ? a.Y : b.Y);
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Десереализация двухмерного вектора из строки
			/// </summary>
			/// <param name="data">Строка данных</param>
			/// <returns>Двухмерный вектор</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Vector2Di DeserializeFromString(String data)
			{
				Vector2Di vector = new Vector2Di();
				String[] vector_data = data.Split(';');
				vector.X = Int32.Parse(vector_data[0]);
				vector.Y = Int32.Parse(vector_data[1]);
				return vector;
			}
			#endregion

			#region ======================================= ДАННЫЕ ====================================================
			/// <summary>
			/// Компонента X
			/// </summary>
			public Int32 X;

			/// <summary>
			/// Компонента Y
			/// </summary>
			public Int32 Y;
			#endregion

			#region ======================================= СВОЙСТВА ==================================================
			/// <summary>
			/// Квадрат длины вектора
			/// </summary>
			public Single SqrLength
			{
				get { return X * X + Y * Y; }
			}

			/// <summary>
			/// Длина вектора
			/// </summary>
			public Single Length
			{
				get { return (Single)Math.Sqrt(X * X + Y * Y); }
			}
			#endregion

			#region ======================================= КОНСТРУКТОРЫ ==============================================
			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Конструктор инициализирует вектор указанными параметрами
			/// </summary>
			/// <param name="x">X - координата</param>
			/// <param name="y">Y - координата</param>
			//---------------------------------------------------------------------------------------------------------
			public Vector2Di(Int32 x, Int32 y)
			{
				X = x;
				Y = y;
			}


			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Конструктор инициализирует вектор указанными параметрами
			/// </summary>
			/// <param name="x">X - координата</param>
			/// <param name="y">Y - координата</param>
			//---------------------------------------------------------------------------------------------------------
			public Vector2Di(Single x, Single y)
			{
				X = (Int32)x;
				Y = (Int32)y;
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Конструктор инициализирует вектор указанным вектором
			/// </summary>
			/// <param name="source_vector">Вектор</param>
			//---------------------------------------------------------------------------------------------------------
			public Vector2Di(Vector2Di source_vector)
			{
				X = source_vector.X;
				Y = source_vector.Y;
			}

#if (UNITY_2017_1_OR_NEWER)
			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Конструктор инициализирует вектор указанным вектором
			/// </summary>
			/// <param name="unity_vector">Вектор</param>
			//---------------------------------------------------------------------------------------------------------
			public Vector2Di(UnityEngine.Vector2 unity_vector)
			{
				X = (Int32)unity_vector.x;
				Y = (Int32)unity_vector.y;
			}
#endif

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Конструктор инициализирует вектор указанным вектором
			/// </summary>
			/// <param name="source">Вектор</param>
			//---------------------------------------------------------------------------------------------------------
			public Vector2Di(Vector2D source)
			{
				X = (Int32)source.X;
				Y = (Int32)source.Y;
			}

#if USE_WINDOWS
			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Конструктор инициализирует вектор указанной точкой WPF
			/// </summary>
			/// <param name="source">Точка WPF</param>
			//---------------------------------------------------------------------------------------------------------
			public Vector2Di(System.Windows.Vector source)
			{
				X = (Int32)source.X;
				Y = (Int32)source.Y;
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Конструктор инициализирует вектор указанной точкой WPF
			/// </summary>
			/// <param name="source">Точка WPF</param>
			//---------------------------------------------------------------------------------------------------------
			public Vector2Di(System.Windows.Point source)
			{
				X = (Int32)source.X;
				Y = (Int32)source.Y;
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Конструктор инициализирует вектор разностью точек WPF
			/// </summary>
			/// <param name="start">Начальная точка WPF</param>
			/// <param name="end">Конечная точка WPF</param>
			//---------------------------------------------------------------------------------------------------------
			public Vector2Di(System.Windows.Point start, System.Windows.Point end)
			{
				X = (Int32)(end.X - start.X);
				Y = (Int32)(end.Y - start.Y);
			}
#endif
#if USE_SHARPDX
			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Конструктор инициализирует вектор указанным вектором SharpDX
			/// </summary>
			/// <param name="source">Вектор SharpDX</param>
			//---------------------------------------------------------------------------------------------------------
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			public Vector2Di(global::SharpDX.Vector2 source)
			{
				X = (Int32)source.X;
				Y = (Int32)source.Y;
			}
#endif
			#endregion

			#region ======================================= СИСТЕМНЫЕ МЕТОДЫ ==========================================
			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Проверяет равен ли текущий объект другому объекту того же типа
			/// </summary>
			/// <param name="obj">Сравниваемый объект</param>
			/// <returns>Статус равенства объектов</returns>
			//---------------------------------------------------------------------------------------------------------
			public override Boolean Equals(Object obj)
			{
				if (obj != null)
				{
					if (typeof(Vector2Di) == obj.GetType())
					{
						Vector2Di vector = (Vector2Di)obj;
						return Equals(vector);
					}
				}
				return base.Equals(obj);
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Проверка равенства векторов по значению
			/// </summary>
			/// <param name="other">Сравниваемый вектор</param>
			/// <returns>Статус равенства векторов</returns>
			//---------------------------------------------------------------------------------------------------------
			public Boolean Equals(Vector2Di other)
			{
				return this == other;
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Сравнение векторов для упорядочивания
			/// </summary>
			/// <param name="other">Сравниваемый вектор</param>
			/// <returns>Статус сравнения векторов</returns>
			//---------------------------------------------------------------------------------------------------------
			public Int32 CompareTo(Vector2Di other)
			{
				if (X > other.X)
				{
					return 1;
				}
				else
				{
					if (X == other.X && Y > other.Y)
					{
						return 1;
					}
					else
					{
						return 0;
					}
				}
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Получение хеш-кода вектора
			/// </summary>
			/// <returns>Хеш-код вектора</returns>
			//---------------------------------------------------------------------------------------------------------
			public override Int32 GetHashCode()
			{
				return X.GetHashCode() ^ Y.GetHashCode();
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Полное копирование вектора
			/// </summary>
			/// <returns>Копия вектора</returns>
			//---------------------------------------------------------------------------------------------------------
			public Object Clone()
			{
				return MemberwiseClone();
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Преобразование к текстовому представлению
			/// </summary>
			/// <returns>Текстовое представление вектора с указанием значений координат</returns>
			//---------------------------------------------------------------------------------------------------------
			public override String ToString()
			{
				return String.Format(ToStringFormat, X, Y);
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Преобразование к текстовому представлению
			/// </summary>
			/// <param name="format">Формат отображения</param>
			/// <returns>Текстовое представление вектора с указанием значений координат</returns>
			//---------------------------------------------------------------------------------------------------------
			public String ToString(String format)
			{
				return "X = " + X.ToString(format) + "; Y = " + Y.ToString(format);
			}
			#endregion

			#region ======================================= ОПЕРАТОРЫ =================================================
			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Сложение векторов
			/// </summary>
			/// <param name="left">Первый вектор</param>
			/// <param name="right">Второй вектор</param>
			/// <returns>Сумма векторов</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Vector2Di operator +(Vector2Di left, Vector2Di right)
			{
				return new Vector2Di(left.X + right.X, left.Y + right.Y);
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Вычитание векторов
			/// </summary>
			/// <param name="left">Первый вектор</param>
			/// <param name="right">Второй вектор</param>
			/// <returns>Разность векторов</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Vector2Di operator -(Vector2Di left, Vector2Di right)
			{
				return new Vector2Di(left.X - right.X, left.Y - right.Y);
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Умножение вектора на скаляр
			/// </summary>
			/// <param name="vector">Вектор</param>
			/// <param name="scalar">Скаляр</param>
			/// <returns>Масштабированный вектор</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Vector2Di operator *(Vector2Di vector, Single scalar)
			{
				return new Vector2Di(vector.X * scalar, vector.Y * scalar);
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Деление вектора на скаляр
			/// </summary>
			/// <param name="vector">Вектор</param>
			/// <param name="scalar">Скаляр</param>
			/// <returns>Масштабированный вектор</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Vector2Di operator /(Vector2Di vector, Single scalar)
			{
				scalar = 1 / scalar;
				return new Vector2Di(vector.X * scalar, vector.Y * scalar);
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Умножение вектора на вектор. Скалярное произведение векторов
			/// </summary>
			/// <param name="left">Первый вектор</param>
			/// <param name="right">Второй вектор</param>
			/// <returns>Скаляр</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Single operator *(Vector2Di left, Vector2Di right)
			{
				return left.X * right.X + left.Y * right.Y;
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Умножение вектора на матрицу трансформации
			/// </summary>
			/// <param name="vector">Вектор</param>
			/// <param name="matrix">Матрица трансформации</param>
			/// <returns>Трансформированный вектор</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Vector2Di operator *(Vector2Di vector, Matrix3Dx2f matrix)
			{
				return new Vector2Di((Int32)(vector.X * matrix.M11 + vector.Y * matrix.M21),
					(Int32)(vector.X * matrix.M12 + vector.Y * matrix.M22));
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Умножение вектора на матрицу трансформации
			/// </summary>
			/// <param name="vector">Вектор</param>
			/// <param name="matrix">Матрица трансформации</param>
			/// <returns>Трансформированный вектор</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Vector2Di operator *(Vector2Di vector, Matrix4Dx4 matrix)
			{
				return new Vector2Di((Int32)(vector.X * matrix.M11 + vector.Y * matrix.M21 + matrix.M41),
					(Int32)(vector.X * matrix.M12 + vector.Y * matrix.M22 + matrix.M42));
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Сравнение векторов на равенство
			/// </summary>
			/// <param name="left">Первый вектор</param>
			/// <param name="right">Второй вектор</param>
			/// <returns>Статус равенства векторов</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Boolean operator ==(Vector2Di left, Vector2Di right)
			{
				return left.X == right.X && left.Y == right.Y;
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Сравнение векторов на неравенство
			/// </summary>
			/// <param name="left">Первый вектор</param>
			/// <param name="right">Второй вектор</param>
			/// <returns>Статус неравенства векторов</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Boolean operator !=(Vector2Di left, Vector2Di right)
			{
				return left.X != right.X || left.Y != right.Y;
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Реализация лексикографического порядка отношений векторов
			/// </summary>
			/// <param name="left">Левый вектор</param>
			/// <param name="right">Правый вектор</param>
			/// <returns>Статус меньше</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Boolean operator <(Vector2Di left, Vector2Di right)
			{
				return left.X < right.X || left.X == right.X && left.Y < right.Y;
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Реализация лексикографического порядка отношений векторов
			/// </summary>
			/// <param name="left">Левый вектор</param>
			/// <param name="right">Правый вектор</param>
			/// <returns>Статус больше</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Boolean operator >(Vector2Di left, Vector2Di right)
			{
				return left.X > right.X || left.X == right.X && left.Y > right.Y;
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Обратный вектор
			/// </summary>
			/// <param name="vector">Исходный вектор</param>
			/// <returns>Обратный вектор</returns>
			//---------------------------------------------------------------------------------------------------------
			public static Vector2Di operator -(Vector2Di vector)
			{
				return new Vector2Di(-vector.X, -vector.Y);
			}
			#endregion

			#region ======================================= ОПЕРАТОРЫ ПРЕОБРАЗОВАНИЯ ==================================
#if (UNITY_2017_1_OR_NEWER)
			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Неявное преобразование в объект типа UnityEngine.Vector2
			/// </summary>
			/// <param name="vector">Вектор</param>
			/// <returns>UnityEngine.Vector2</returns>
			//---------------------------------------------------------------------------------------------------------
			public static implicit operator UnityEngine.Vector2(Vector2Di vector)
			{
				return new UnityEngine.Vector2(vector.X, vector.Y);
			}
#endif
#if USE_WINDOWS
			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Неявное преобразование в объект типа точки WPF
			/// </summary>
			/// <param name="vector">Вектор</param>
			/// <returns>Точка WPF</returns>
			//---------------------------------------------------------------------------------------------------------
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			public static implicit operator System.Windows.Point(Vector2Di vector)
			{
				return (new System.Windows.Point(vector.X, vector.Y));
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Неявное преобразование в объект типа вектора WPF
			/// </summary>
			/// <param name="vector">Вектор</param>
			/// <returns>Вектор WPF</returns>
			//---------------------------------------------------------------------------------------------------------
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			public static implicit operator System.Windows.Vector(Vector2Di vector)
			{
				return (new System.Windows.Vector(vector.X, vector.Y));
			}
#endif
#if USE_GDI
			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Неявное преобразование в объект типа точки System.Drawing
			/// </summary>
			/// <param name="vector">Вектор</param>
			/// <returns>Точка System.Drawing</returns>
			//---------------------------------------------------------------------------------------------------------
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			public static implicit operator System.Drawing.Point(Vector2Di vector)
			{
				return (new System.Drawing.Point((Int32)vector.X, (Int32)vector.Y));
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Неявное преобразование в объект типа точки System.Drawing
			/// </summary>
			/// <param name="vector">Вектор</param>
			/// <returns>Точка System.Drawing</returns>
			//---------------------------------------------------------------------------------------------------------
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			public static implicit operator System.Drawing.PointF(Vector2Di vector)
			{
				return (new System.Drawing.PointF(vector.X, vector.Y));
			}
#endif
			#endregion

			#region ======================================= ИНДЕКСАТОР ================================================
			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Индексация компонентов вектора на основе индекса
			/// </summary>
			/// <param name="index">Индекс компонента</param>
			/// <returns>Компонента вектора</returns>
			//---------------------------------------------------------------------------------------------------------
			public Int32 this[Int32 index]
			{
				get
				{
					switch (index)
					{
						case 0:
							return X;
						default:
							return Y;
					}
				}
				set
				{
					switch (index)
					{
						case 0:
							X = value;
							break;
						default:
							Y = value;
							break;
					}
				}
			}
			#endregion

			#region ======================================= ОБЩИЕ МЕТОДЫ ==============================================
			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Смещение вектора
			/// </summary>
			/// <param name="x">Смещение по X</param>
			/// <param name="y">Смещение по Y</param>
			//---------------------------------------------------------------------------------------------------------
			public void Offset(Int32 x, Int32 y)
			{
				X += x;
				Y += y;
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Смещение вектора
			/// </summary>
			/// <param name="x">Смещение по X</param>
			/// <param name="y">Смещение по Y</param>
			//---------------------------------------------------------------------------------------------------------
			public void Offset(Single x, Single y)
			{
				X += (Int32)x;
				Y += (Int32)y;
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Вычисление расстояние до вектора
			/// </summary>
			/// <param name="vector">Вектор</param>
			/// <returns>Расстояние до вектора</returns>
			//---------------------------------------------------------------------------------------------------------
			public Single Distance(Vector2Di vector)
			{
				Single x = vector.X - X;
				Single y = vector.Y - Y;

				return (Int32)Math.Sqrt(x * x + y * y);
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Вычисление скалярного произведения векторов
			/// </summary>
			/// <param name="vector">Вектор</param>
			/// <returns>Скалярное произведение векторов</returns>
			//---------------------------------------------------------------------------------------------------------
			public Single Dot(Vector2Di vector)
			{
				return X * vector.X + Y * vector.Y;
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Установка компонентов вектора из наибольших компонентов двух векторов
			/// </summary>
			/// <param name="a">Первый вектор</param>
			/// <param name="b">Второй вектор</param>
			//---------------------------------------------------------------------------------------------------------
			public void SetMaximize(Vector2Di a, Vector2Di b)
			{
				X = a.X > b.X ? a.X : b.X;
				Y = a.Y > b.Y ? a.Y : b.Y;
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Установка компонентов вектора из наименьших компонентов двух векторов
			/// </summary>
			/// <param name="a">Первый вектор</param>
			/// <param name="b">Второй вектор</param>
			//---------------------------------------------------------------------------------------------------------
			public void SetMinimize(Vector2Di a, Vector2Di b)
			{
				X = a.X < b.X ? a.X : b.X;
				Y = a.Y < b.Y ? a.Y : b.Y;
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Трансформация вектора как точки
			/// </summary>
			/// <param name="matrix">Матрица трансформации</param>
			//---------------------------------------------------------------------------------------------------------
			public void TransformAsPoint(Matrix3Dx2f matrix)
			{
				this = new Vector2Di(X * matrix.M11 + Y * matrix.M21 + matrix.M31,
									X * matrix.M12 + Y * matrix.M22 + matrix.M31);
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Трансформация вектора как точки
			/// </summary>
			/// <param name="matrix">Матрица трансформации</param>
			//---------------------------------------------------------------------------------------------------------
			public void TransformAsPoint(Matrix4Dx4 matrix)
			{
				this = new Vector2Di((Int32)(X * matrix.M11 + Y * matrix.M21 + matrix.M41),
									(Int32)(X * matrix.M12 + Y * matrix.M22 + matrix.M42));
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Трансформация вектора как вектора
			/// </summary>
			/// <param name="matrix">Матрица трансформации</param>
			//---------------------------------------------------------------------------------------------------------
			public void TransformAsVector(Matrix3Dx2f matrix)
			{
				this = new Vector2Di(X * matrix.M11 + Y * matrix.M21,
									X * matrix.M12 + Y * matrix.M22);
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Трансформация вектора как вектора
			/// </summary>
			/// <param name="matrix">Матрица трансформации</param>
			//---------------------------------------------------------------------------------------------------------
			public void TransformAsVector(Matrix4Dx4 matrix)
			{
				this = new Vector2Di((Int32)(X * matrix.M11 + Y * matrix.M21),
									(Int32)(X * matrix.M12 + Y * matrix.M22));
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Сериализация вектора в строку
			/// </summary>
			/// <returns>Строка данных</returns>
			//---------------------------------------------------------------------------------------------------------
			public String SerializeToString()
			{
				return String.Format("{0};{1}", X, Y);
			}
			#endregion

			#region ======================================= МЕТОДЫ ПРЕОБРАЗОВАНИЙ =====================================
			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Преобразование в вектор нулевой X компонентой
			/// </summary>
			/// <returns>Вектор</returns>
			//---------------------------------------------------------------------------------------------------------
			public Vector2Di ToVector2X()
			{
				return new Vector2Di(X, 0);
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Преобразование в вектор нулевой Y компонентой
			/// </summary>
			/// <returns>Вектор</returns>
			//---------------------------------------------------------------------------------------------------------
			public Vector2Di ToVector2Y()
			{
				return new Vector2Di(0, Y);
			}
			#endregion
		}
		//-------------------------------------------------------------------------------------------------------------
		/*@}*/
		//-------------------------------------------------------------------------------------------------------------
	}
}
//=====================================================================================================================